<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-09T21:21:28+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">JVM 구조와 Java 런타임 구조</title><link href="http://localhost:4000/java/2021/01/09/JVM_Memory_Structure.html" rel="alternate" type="text/html" title="JVM 구조와 Java 런타임 구조" /><published>2021-01-09T00:00:00+09:00</published><updated>2021-01-09T00:00:00+09:00</updated><id>http://localhost:4000/java/2021/01/09/JVM_Memory_Structure</id><content type="html" xml:base="http://localhost:4000/java/2021/01/09/JVM_Memory_Structure.html">&lt;h2 id=&quot;jvm-메모리-구조와-자바가-실행될-때-jvm에서-일어나는-일을-알아보자&quot;&gt;JVM 메모리 구조와 자바가 실행될 때 JVM에서 일어나는 일을 알아보자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;출처: &lt;a href=&quot;https://jeong-pro.tistory.com/148&quot;&gt;https://jeong-pro.tistory.com/148&lt;/a&gt; (기본기를 쌓는 정아마추어 코딩블로그)&lt;/li&gt;
  &lt;li&gt;추가 참고 자료: &lt;a href=&quot;https://sehun-kim.github.io/sehun/JVM/&quot;&gt;https://sehun-kim.github.io/sehun/JVM/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;JVM(Java Virtual Machine)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;: 자바 가상 머신으로 &lt;strong&gt;자바 바이트 코드를 실행할 수 있는 주체&lt;/strong&gt;다.&lt;/p&gt;

&lt;p&gt;CPU나 운영체제(플랫폼)의 종류와 무관하게 실행이 가능하다.&lt;/p&gt;

&lt;p&gt;즉, 운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;JVM의 구성을 살펴보면 크게 4가지(Class Loader, Execution Engine, Garbage Collector, Runtime Data Area)로 나뉜다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/9973563D5ACE031521&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Class Loader&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바에서 소스를 작성하면 Person.java 처럼 .java파일이 생성된다.&lt;/p&gt;

&lt;p&gt;.java 소스를 자바컴파일러가 컴파일하면 Person.class 같은 .class파일(바이트코드)이 생성된다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 클래스파일들을 엮어서 JVM이 운영체제로부터 할당받은 메모리영역인 Runtime Data Area로 적재하는 역할을 Class Loader가 한다. (자바 애플리케이션이 &lt;strong&gt;실행중&lt;/strong&gt;일 때 이런 작업이 수행된다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Execution Engine&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Class Loader에 의해 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;명령어를 하나 하나 실행하는 인터프리터(Interpreter)방식이 있고 JIT(Just-In-Time) 컴파일러를 이용하는 방식이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Garbage Collector&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다. (참조가 없어지자마자 해제되는 것을 보장하지 않음)&lt;/p&gt;

&lt;p&gt;또 다른 특징은 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지된다.&lt;/p&gt;

&lt;p&gt;특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있는 것이다. (GC와 관련된 내용은 아래 Heap영역 메모리를 설명할 때 더 자세히 알아본다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Runtime Data Area&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.&lt;/p&gt;

&lt;p&gt;이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;자바 런타임 메모리(Runtime Data area)구조&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/99AED1445ACE0E4B04&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Method area (메소드 영역)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Heap area (힙 영역)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;new 키워드로 생성된 객체와 배열이 생성되는 영역이다.&lt;/p&gt;

&lt;p&gt;메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Stack area (스택 영역)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.&lt;/p&gt;

&lt;p&gt;int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다.&lt;/p&gt;

&lt;p&gt;클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있다. 즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것이다.&lt;/p&gt;

&lt;p&gt;메소드를 호출할 때마다 개별적으로 스택이 생성된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. PC Register (PC 레지스터)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thread(쓰레드)가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. (*CPU의 레지스터와 다름)&lt;/p&gt;

&lt;p&gt;이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Native method stack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.&lt;/p&gt;

&lt;p&gt;보통 C/C++등의 코드를 수행하기 위한 스택이다. (JNI)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쓰레드가 생성되었을 때 기준으로&lt;/p&gt;

&lt;p&gt;1,2번인 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고,&lt;/p&gt;

&lt;p&gt;3,4,5번인 스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Heap area &amp;amp; Garbage Collector&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;힙 영역은 좀 더 살펴봐야하는데 그 이유는 GC의 주요 대상이기 때문이다.&lt;/p&gt;

&lt;p&gt;(Stack영역과 Method영역도 GC의 대상이 된다)&lt;/p&gt;

&lt;p&gt;힙 영역은 우선 5개의 영역(eden, survivor1, survivor2, old, permanent)으로 나뉜다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; JDK7까지는 permanent영역이 heap에 존재했습니다. JDK8부터는 permanent 영역은 사라지고 일부가 “meta space 영역”으로 변경되었습니다.(위의 그림 JDK7 기준입니다.) meta space 영역은 Native stack 영역에 포함되었습니다.&lt;/p&gt;

&lt;p&gt;(survivor영역의 숫자는 의미없고 두 개로 나뉜다는 것이 중요하다)&lt;/p&gt;

&lt;p&gt;힙 영역을 굳이 5개로 나눈 이유는 효율적으로 GC가 일어나게 하기 위함이다. 자세한 것은 GC가 일어나는 프로세스를 보면서 설명한다.&lt;/p&gt;

&lt;p&gt;GC는 Minor GC와 Major GC로 나뉜다.&lt;/p&gt;

&lt;p&gt;- &lt;strong&gt;Minor GC : New 영역에서 일어나는 GC&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;최초에 객체가 생성되면 Eden영역에 생성된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eden영역에 객체가 가득차게 되면 첫 번째 CG가 일어난다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;survivor1 영역에 Eden영역의 메모리를 그대로 복사된다. 그리고 survivor1 영역을 제외한 다른 영역의 객체를 제거한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eden영역도 가득차고 survivor1영역도 가득차게된다면, Eden영역에 생성된 객체와 survivor1영역에 생성된 객체 중에 참조되고 있는 객체가 있는지 검사한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참조 되고있지 않은 객체는 내버려두고 참조되고 있는 객체만 survivor2영역에 복사한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;survivor2영역을 제외한 다른 영역의 객체들을 제거한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 과정중에 일정 횟수이상 참조되고 있는 객체들을 survivor2에서 Old영역으로 이동시킨다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;- 위 과정을 계속 반복, survivor2영역까지 꽉차기 전에 계속해서 Old로 비움&lt;/p&gt;

&lt;p&gt;- &lt;strong&gt;Major GC(Full GC) : Old 영역에서 일어나는 GC&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Old 영역에 있는 모든 객체들을 검사하며 참조되고 있는지 확인한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참조되지 않은 객체들을 모아 한 번에 제거한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;- Minor GC보다 시간이 훨씬 많이 걸리고 실행중에 GC를 제외한 모든 쓰레드가 중지한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;* Major GC(Full GC)가 일어나면,&lt;/p&gt;

&lt;p&gt;Old영역에 있는 참조가 없는 객체들을 표시하고 그 해당 객체들을 모두 제거하게 된다.&lt;/p&gt;

&lt;p&gt;그러면서 Heap 메모리 영역에 중간중간 구멍(제거되고 빈 메모리 공간)이 생기는데 이 부분을 없애기 위해 재구성을 하게 된다. (디스크 조각모음처럼 조각난 메모리를 정리함)&lt;/p&gt;

&lt;p&gt;따라서 메모리를 옮기고 있는데 다른 쓰레드가 메모리를 사용해버리면 안되기 때문에 모든 쓰레드가 정지하게 되는 것이다.&lt;/p&gt;</content><author><name></name></author><category term="Java" /><category term="JVM" /></entry><entry><title type="html">21년 1월 9일</title><link href="http://localhost:4000/til/2021/01/09/TIL6.html" rel="alternate" type="text/html" title="21년 1월 9일" /><published>2021-01-09T00:00:00+09:00</published><updated>2021-01-09T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/09/TIL6</id><content type="html" xml:base="http://localhost:4000/til/2021/01/09/TIL6.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JVM의 메모리 구조와 Java Application이 실행되는 과정을 공부하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;제가 이해한 내용은 다음과 같은데, 혹시 잘못된 점이 있다면 isaac56@naver.com 으로 메일 주시면 감사하겠습니다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Java 컴파일러(Javac)가 java소스파일을 class 파일(자바 바이트 코드)로 컴파일한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;JRE가 main 메소드가 있는 클래스 파일을 찾는다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;찾았다면 JVM의 Class loader가 해당 클래스에 대한 정보를 Runtime Data Area 중 Method영역에 적재한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;JVM의 Excecution Engine이 main 메소드에 해당하는 코드를 읽어 Stack Frame을 구성하고, PC Register영역에 현재 실행중인 코드 주소를 저장한다.&lt;/p&gt;

        &lt;p&gt;(Excecution Engine은 인터프리터(Interpreter)방식 또는 JIT(Just-In-Time) 컴파일러 방식으로 코드를 실행한다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;코드가 실행되며 어떤 객체의 인스턴스가 생성된다면 Heap영역에 생성되고 Stack Frame에는 해당 인스턴스에 대한 참조값이 저장된다.&lt;/li&gt;
      &lt;li&gt;PC Register에서 실행중인 코드 주소가 변경되가며, 해당하는 코드를 Execution Engine이 실행하는 방식으로 어플리케이션이 실행된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주말이라 마음이 느슨해졌고, 본가에 방문하다 보니 좀 많이 놀게 되었다.&lt;/li&gt;
  &lt;li&gt;오늘도 알고리즘 공부를 하지 않았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머스 알고리즘 문제를 풀다가 기본이 부족하다는 것을 깨닫고 JVM에서 Java Application을 실행하는 과정을 찾아 공부하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;갑자기 JVM 구조를 공부하고 포스팅한 흐름은 다음과 같다.
    &lt;ol&gt;
      &lt;li&gt;알고리즘 문제를 Priority Queue를 이용해 풀려고 했다.&lt;/li&gt;
      &lt;li&gt;Priority Queue사용법을 테스트하다 보니 static메소드인 main에서 local inner class를 사용할 수 없다는 점을 깨달았다.&lt;/li&gt;
      &lt;li&gt;왜 그럴까 찾아보다가, 애초에 Java Application이 실행되는 과정과 JVM의 구조도 모른다는 점을 알게 되었다.&lt;/li&gt;
      &lt;li&gt;기초부터 공부하려고 JVM구조를 공부 후 포스팅하였다.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;항상 찜찜한 기분이었던 JVM 구조를 알게되어서 다소 개운한 느낌이다.&lt;/li&gt;
  &lt;li&gt;주말에는 좀 널널히 공부하려고 마음먹긴 했지만 예상보다 너무 많이 놀아서 죄책김이 든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JVM의 구조를 알게 되었으니, Nested Class의 내용을 찾아서 정리해보자.&lt;/li&gt;
  &lt;li&gt;내일은 꼭 알고리즘 2문제를 푼 후, 자바의정석을 읽어보려고 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="JVM" /><category term="Java" /></entry><entry><title type="html">21년 1월 8일</title><link href="http://localhost:4000/til/2021/01/08/TIL5.html" rel="alternate" type="text/html" title="21년 1월 8일" /><published>2021-01-08T00:00:00+09:00</published><updated>2021-01-08T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/08/TIL5</id><content type="html" xml:base="http://localhost:4000/til/2021/01/08/TIL5.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;어제 코드스쿼드 미션으로 나온 쉘 스크립트의 부족한 부분을 수정했다&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;현재 폴더에 위치한 day1 ~ day16 폴더의 .cs 파일만을 복사해야 하는데,&lt;/p&gt;

        &lt;p&gt;어제의 스크립트는 현재 폴더 하위에 위치한 모든 .cs 파일을 압축했었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;변경전 쉘 스크립트&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;var &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;1..16&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
  if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; not exists&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
    if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; day&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; .cs | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
      &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; is empty&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi
  fi
done
       
&lt;/span&gt;find &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;*.cs&quot;&lt;/span&gt; | xargs zip &lt;span class=&quot;nv&quot;&gt;$NAME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; log.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;변경후 쉘 스크립트&lt;/p&gt;

            &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;targetFiles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=()&lt;/span&gt;
       
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;var &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;1..16&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
  if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; not exists&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else
    if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; day&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; .cs | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
      &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;day&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; is empty&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else
      &lt;/span&gt;targetFiles+&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;day&lt;span class=&quot;nv&quot;&gt;$var&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.cs&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi
  fi
done
       
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;backup_&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt; +&lt;span class=&quot;s2&quot;&gt;&quot;%y%m%d&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.zip&quot;&lt;/span&gt;
zip &lt;span class=&quot;nv&quot;&gt;$NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;targetFiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ./log.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SCP명령어에서 패스워드 입력없이 바로 사용할 수 있도록 SSH Key 방식을 사용했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공개키와 개인키로 이루어지는 SSH Key 인증 방식을 공부하고, 정리하여 포스팅했다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;계획에 없던 개인 스케줄로 인해, 목표한 책을 펴지도 않았고, 알고리즘 2문제를 풀지도 못했다.&lt;/li&gt;
  &lt;li&gt;세운 계획이 구체적이지도 못하고 하루에 소화할만 한 양이 아닌 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SSH key 인증이 어떻게 이루어지는지 찾아보고, 실제 적용하여 쉘 스크립트를 완전 자동화 하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;계획을 어떤 식으로 세워야 할지가 고민이다.
    &lt;ul&gt;
      &lt;li&gt;너무 대충 세운 계획이나 무리한 계획을 세우지 말고, 오늘 공부할 주제만 정하고 시간에 충실하게 공부하는게 어떨까 싶다.&lt;/li&gt;
      &lt;li&gt;예를 들어, 프로그래머스 2문제를 푸는게 계획이면 어려운 문제가 걸리면 계획에 맞추기 힘들 수 있다.&lt;/li&gt;
      &lt;li&gt;책 읽기도 하루에 몇페이지를 읽어야 한다기보다, 공부하는 시간에 충실하게 읽는 것을 목표로 하는게 어떨까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매일 공부한 것 중에 기억할 만한 개념을 글로 정리하고 있는데, 글 재주가 없어서 그런지 글로 정리하는데 시간이 너무 많이 쓰인다.
    &lt;ul&gt;
      &lt;li&gt;내가 공부하고 공부한 것을 기억하는 것이 중요하기 때문에, 시간을 절약하려면 나만 알아볼 수 있는 수준만큼만 작성하는게 어떨까 싶다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘 공부&lt;/li&gt;
  &lt;li&gt;자바의정석 책 공부&lt;/li&gt;
  &lt;li&gt;TCP/IP 공부&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="SSH" /><category term="shell" /></entry><entry><title type="html">SSH key를 이용한 접속</title><link href="http://localhost:4000/linux/2021/01/08/SSH-Key-How.html" rel="alternate" type="text/html" title="SSH key를 이용한 접속" /><published>2021-01-08T00:00:00+09:00</published><updated>2021-01-08T00:00:00+09:00</updated><id>http://localhost:4000/linux/2021/01/08/SSH-Key-How</id><content type="html" xml:base="http://localhost:4000/linux/2021/01/08/SSH-Key-How.html">&lt;h2 id=&quot;ssh-key란&quot;&gt;SSH Key란&lt;/h2&gt;

&lt;p&gt;SSH 접속은 패스워드로도 할 수 있지만, 안전한 인증방식은 아니라고 한다.&lt;/p&gt;

&lt;p&gt;컴퓨팅 파워가 증가하면서 password를 단순 대입하며 bruth force 방식으로 접속 시도를 할 수 있고,&lt;/p&gt;

&lt;p&gt;사람이 기억할 만한 password는 대부분 burth force 방식을 막을만큼 충분히 길지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이제, password 대신 ssh key라는 추가적인 보안 방식을 사용해보자.&lt;/p&gt;

&lt;p&gt;ssh key는 공개키와 개인키로 나뉘어져 있다.&lt;/p&gt;

&lt;p&gt;공개키와 개인키는 대칭키로, 각각의 키로 암호화한 암호는 대칭되는 키로만 해석이 가능하다.&lt;/p&gt;

&lt;p&gt;즉, 공개키로 암호화한 암호는 개인키로만 해석이 가능하고, 개인키로 암호화한 암호는 공개키로만 해석이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
공개키는 아무에게나 공개해도 되지만 개인키는 절대 타인에게 공개해서는 안되는데 그이유는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;공개키로 암호화한 암호는 개인키를 가진 나만이 해석할 수 있기 때문에, 나만 볼 수 있게 하기위한 비밀메세지와 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공개키로 해석할 수 있는 암호는 개인키를 가진 나만이 만들 수 있기 때문에, 개인키로 암호화한 암호는 내가 나임을 인증하려는 인증서의 목적이 크다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;따라서 나의 개인키를 공개한다는 것은 아무나 나인척 할 수 있게 만드는 것이다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ssh-서버에-ssh-key로-인증하는-방식&quot;&gt;SSH 서버에 SSH Key로 인증하는 방식&lt;/h2&gt;

&lt;p&gt;SSH Key로 인증을 위해 나의 공개키가 서버안의 authorized_keys 파일에 등록되었다고 가정하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
SSH를 인증하는 방식은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트(나)가 서버에 SSH연결을 요청한다.&lt;/li&gt;
  &lt;li&gt;서버는 랜덤 스트링을 생성하여 클라이언트에게 보낸다.&lt;/li&gt;
  &lt;li&gt;클라이언트(나)는 전달받은 랜덤 스트링을 개인키로 암호화하여 서버에게 보낸다.&lt;/li&gt;
  &lt;li&gt;서버는 받은 암호를 authorized_keys에 등록된 공개키로 해석한 후, 2번에서 보냈던 랜덤 스트링과 일치하는지 확인한다.&lt;/li&gt;
  &lt;li&gt;일치한다면 클라이언트(나)는 authorized_keys에 등록된 authorized client 중 하나이므로 인증완료된다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Linux" /><category term="SSH" /></entry><entry><title type="html">리눅스 group이란, group 변경</title><link href="http://localhost:4000/linux/2021/01/08/userGroup.html" rel="alternate" type="text/html" title="리눅스 group이란, group 변경" /><published>2021-01-08T00:00:00+09:00</published><updated>2021-01-08T00:00:00+09:00</updated><id>http://localhost:4000/linux/2021/01/08/userGroup</id><content type="html" xml:base="http://localhost:4000/linux/2021/01/08/userGroup.html">&lt;h2 id=&quot;리눅스에서-group이란&quot;&gt;리눅스에서 group이란&lt;/h2&gt;

&lt;p&gt;리눅스에선 group이라는 것이 있는데, 어떤 파일이나 폴더를 특정 User에게만 공유하고 싶을 때 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;root 디렉터리에서 ls -l 커맨드를 치면 아래와 같은 형식으로 폴더 및 파일 정보가 뜬다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;drwxr-xr-x  93 root root     4096  Jan  8 01:25 etc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rwxr-xr-x&lt;/code&gt; 는 etc라는 폴더에 접근 권한이다.&lt;/li&gt;
  &lt;li&gt;3글자씩 잘라서, 소유자/그룹/타인 에 대한 접근 권한이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;root root&lt;/code&gt; 는 소유자/그룹 이 누구인지를 뜻한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 때, group1이라는 그룹에 속한 사용자들에게만 권한을 주고 싶다면,&lt;/p&gt;

&lt;p&gt;해당 폴더의 그룹을 group1으로 바꾸고 그룹에 대한 접근 권한을 설정해주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;현재-생성되어-있는-group-확인&quot;&gt;현재 생성되어 있는 Group 확인&lt;/h3&gt;

&lt;p&gt;현재 생성되어 있는 group은 /etc/group 파일에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;특정-유저의-그룹-확인&quot;&gt;특정 유저의 그룹 확인&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#id user1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;그룹-생성하기&quot;&gt;그룹 생성하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#groupadd -g 777 group1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;GID가 777인 그룹 group1을 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;유저를-그룹에-가입시키기&quot;&gt;유저를 그룹에 가입시키기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#usermod -G group1 user1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;user1을 group1에 가입시킨다.&lt;/li&gt;
  &lt;li&gt;user1이 세 개 이상 그룹에 가입하기 위해서는 /etc/group을 수정해야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그룹-삭제하기&quot;&gt;그룹 삭제하기&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#groupdel group1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;group1을 삭제 시킨다.&lt;/li&gt;
  &lt;li&gt;group1을 기본그룹으로 하는 user가 있다면 삭제가 안됨&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Linux" /><category term="group" /></entry><entry><title type="html">Shell의 종류</title><link href="http://localhost:4000/linux/2021/01/08/Shell-type.html" rel="alternate" type="text/html" title="Shell의 종류" /><published>2021-01-08T00:00:00+09:00</published><updated>2021-01-08T00:00:00+09:00</updated><id>http://localhost:4000/linux/2021/01/08/Shell-type</id><content type="html" xml:base="http://localhost:4000/linux/2021/01/08/Shell-type.html">&lt;p&gt;&lt;strong&gt;1. sh (bourne shell)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가장 기본적인 쉘로 유닉스의 초기부터 사용되어 온 쉘이며 스크립트를 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. ksh (korn shell)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;본 쉘을 확장한 쉘로 본 쉘 명령어를 모두 인식한다. 히스토리(history) 기능과 앨리어스(alias), 작업 제어 등의 기능이 추가되었다. 일반적으로 유닉스에서 가장 많이 사용되는 쉘이라고 한다. 명령행 편집기능을 제공&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. bash (Bourne Again Shell)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리눅스에서 가장 많이 사용하는 쉘이다. C 쉘과 콘 쉘의 장점을 결합하여 작성되었으며, Bourne 쉘 문법의 명령어 셋을 제공하여 Bourne Shell과 호환되는 쉘로 GNU 프로젝트에 의해 만들어지고 배포되었다. 명령행 편집기능을 제공&lt;/p&gt;

&lt;h3 id=&quot;c-쉘-계열의-쉘&quot;&gt;C 쉘 계열의 쉘&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. csh (C Shell)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령행 편집기능을 제공하지 않는다. C 언어 위주의 쉘로 처음 작성되었을 때에는 본 쉘이 가지고 있지 못한 기능들(작업제어, 명령어 히스토리 등)을 가지고 있었기 때문에 많이 사용되었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. tcsh (TC Shell)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;csh의 기능을 강화한 쉘입니다. 명령행 편집기능을 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;centos-sulinux-asianux-등의-레드햇-계열의-리눅스-배포판에서-기본으로-사용되지-않는-쉘&quot;&gt;CentOS, SULinux, Asianux 등의 레드햇 계열의 리눅스 배포판에서 기본으로 사용되지 않는 쉘&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. Zsh 쉘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;로그인쉘 및 쉘스크립트 명령어 프로세서로서 이용 가능한 유닉스 쉘입니다. 표준 쉘들 중에서 zsh는 ksh와 가장 유사하지만 많은 개선들을 포함합니다. zsh는 명령행 편집, 내장 스펠링 수정, history 등의 기능을 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. ash 쉘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;추가적인 기능들이 없이 본 쉘에 가장 부합하는 쉘입니다. 본 쉘은 상업적인 유닉스 시스템들에서 사용가능하므로, ash는 쉘 스크립트가 본 쉘에 잘 부합하는지 시험할 때 유용합니다. 또한 이것은 다른 sh- 호환 쉘에 비해 적은 메모리와 공간을 요구합니다.&lt;/p&gt;</content><author><name></name></author><category term="Linux" /><category term="Shell" /></entry><entry><title type="html">21년 1월 7일</title><link href="http://localhost:4000/til/2021/01/07/TIL4.html" rel="alternate" type="text/html" title="21년 1월 7일" /><published>2021-01-07T00:00:00+09:00</published><updated>2021-01-07T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/07/TIL4</id><content type="html" xml:base="http://localhost:4000/til/2021/01/07/TIL4.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linux SSH 서버 설치 및 config 방법 (Ubuntu)&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;linux에 SSH가 설치되어 있지 않는 경우 SSH를 설치한다&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#SSH 서버 클라이언트 모두 설치&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get ssh
&lt;span class=&quot;c&quot;&gt;#서버만 설치하고 싶으면&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get openssh-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;/etc/ssh/sshd_config 파일을 통해 SSH 설정을 변경할 수 있다.&lt;/p&gt;

        &lt;p&gt;참고: &lt;a href=&quot;http://programmingskills.net/archives/315&quot;&gt;http://programmingskills.net/archives/315&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Virtual Box으로 실행한 ubuntu에 ssh로 접속하기 (MAC 기준)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;VM 내부 ubuntu에서 ifconfig 명령어로 사설 IP를 확인한다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/public/img/210107/1.png&quot; alt=&quot;image-20210107133137703&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;기존 OS (host OS) 에서 사설 IP를 확인한다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;맥은 터미널에서 ifconfg 또는 시스템환경설정 - 네트워크에서 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;VirtualBox 에서 ubuntu 설정 - 네트워크 - 고급 - 포트포워드 클릭&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/public/img/210107/2.png&quot; alt=&quot;image-20210107134958414&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;호스트 IP에 원래 OS의 IP주소, 호스트 포트에 접속할 때 사용할 호스트 포트를 입력한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;게스트 IP에 vm내부의 ubuntu IP주소를 입력하고, 게스트 포트에는 22를 입력한다.(SSH의 기본 포트는 22이고, unbuntu내에서 ssh 포트를 수정하였다면 수정한 포트 번호를 입력한다.)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/public/img/210107/3.png&quot; alt=&quot;image-20210107135348581&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맥에는 기본적으로 tree명령어가 없기 때문에 tree명령어를 설치해보았다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Homebrew는 Apple에서 제공하지 않는 패키지 관리자를 설치할 수 있다.&lt;/p&gt;

        &lt;p&gt;Homebrew를 설치한다&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/bin/bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;homebrew를 통해 tree명령어를 설치한다&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;tree
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 간단한 shell script를 짜보았다.&lt;/p&gt;

    &lt;p&gt;사용한 것은 아래에 적어놓았고 기본적인 쉘스크립트 문법은 구글링해서 익히자.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;해당 폴더가 존재하는지 확인&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ ! -d &amp;lt;폴더명&amp;gt; ]; then
  #do
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;해당 파일이 존재하는지 확인&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ ! -f &amp;lt;파일명&amp;gt; ]; then
  #do
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;특정 형식의 파일이 존재하는지 확인&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if [ $(find &amp;lt;폴더&amp;gt; -name &amp;lt;파일형식(*.cs 등)&amp;gt; | wc -l) -eq 0 ]; then
	#do
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;특정 형식의 파일만 zip로 압축 (tar도 거의 동일)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find &amp;lt;폴더&amp;gt; -name &amp;lt;파일형식(*.cs 등)&amp;gt; | xargs zip &amp;lt;압축파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;scp로 remote에 파일 복사&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp -P &amp;lt;포트번호&amp;gt; &amp;lt;복사할 파일명&amp;gt; &amp;lt;remote계정&amp;gt;@&amp;lt;remote IP&amp;gt;:&amp;lt;remote 파일경로(이 경로의 파일명으로 복사됨)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스에서 [다리를 지나는 트럭], [프린터] 2문제를 풀었다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;두 문제 다 queue를 이용하여 푸는 문제였다. 이미 풀었던 문제를 Java로 풀어보았다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Java의 정석과 TCP/IP 더 쉽게 책을 보지 못했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;VM을 설치하여 ubuntu를 설치하고, SSH를 연결한 후, 호스트에서 특정 파일을 압축하여 게스트OS로 보내는 과정을 쉘 스크립트로 자동화 하였다.
    &lt;ul&gt;
      &lt;li&gt;SSH를 연결하는 과정에서 포트포워딩을 해보았고 이를 통해 NAT이라는 네트워크 개념을 익힌 후 글로 정리하였다.&lt;/li&gt;
      &lt;li&gt;SCP로 파일을 전송하는 과정에서 permission denied를 겪었고 이를 통해, Linux에서 Directory의 소유자, 그룹에 따른 권한이 어떻게 적용되는지 알게 되었다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코드스쿼드에서 준 미션을 단순히 풀기만 함으로써 네트워크 관련 지식을 검색하고 알게 되어 좋았다.&lt;/li&gt;
  &lt;li&gt;내가 정한 계획을 지키지 못했지만, 게을러서 지키지 못했다기보다 다른 공부거리가 생겨 이를 하다 보니 시간이 늦어버렸다.
    &lt;ul&gt;
      &lt;li&gt;오늘 호눅스가 얘기한 말을 기억하며,
        &lt;ol&gt;
          &lt;li&gt;전에 세웠던 계획을 다 소화 못하면 그것을 뒤로 미루지 말고 계획을 줄여서 새로 세우자!&lt;/li&gt;
          &lt;li&gt;내가 지치면 암것도 못한다. 길게 보고 최선을 다하자&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머스 2문제 풀기&lt;/li&gt;
  &lt;li&gt;Java의 정석 읽기&lt;/li&gt;
  &lt;li&gt;TCP/IP쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Blog" /><category term="jekyll" /><category term="Github" /><category term="Git" /></entry><entry><title type="html">SSH root 권한으로 접속 허용하기</title><link href="http://localhost:4000/linux/2021/01/07/permitSSH_Root.html" rel="alternate" type="text/html" title="SSH root 권한으로 접속 허용하기" /><published>2021-01-07T00:00:00+09:00</published><updated>2021-01-07T00:00:00+09:00</updated><id>http://localhost:4000/linux/2021/01/07/permitSSH_Root</id><content type="html" xml:base="http://localhost:4000/linux/2021/01/07/permitSSH_Root.html">&lt;h2 id=&quot;ssh-root-권한으로-접속-허용하기&quot;&gt;SSH root 권한으로 접속 허용하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SCP 명령어로 remote의 특정 폴더에 접근하려면 root권한이 필요할 때가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분명히 root 비밀번호가 맞았는데도 자꾸 Permission denied, please try again. 가 뜬다면 ssh 설정을 확인해야한다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;remote(ubuntu 기준) 로 들어가서 /etc/ssh/sshd_config 파일을 연다&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;파일 내의 PermitRootLogin 을 yes로 바꿔준다. (없으면 추가한다.)&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PermitRootLogin &lt;span class=&quot;nb&quot;&gt;yes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;데몬 명령어로 ssh를 재시작시켜 변경된 설정을 적용한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl restart ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Linux" /><category term="SSH" /></entry><entry><title type="html">su: Authentication failure 발생하는 이유</title><link href="http://localhost:4000/linux/2021/01/07/rootPwdSet.html" rel="alternate" type="text/html" title="su: Authentication failure 발생하는 이유" /><published>2021-01-07T00:00:00+09:00</published><updated>2021-01-07T00:00:00+09:00</updated><id>http://localhost:4000/linux/2021/01/07/rootPwdSet</id><content type="html" xml:base="http://localhost:4000/linux/2021/01/07/rootPwdSet.html">&lt;h1 id=&quot;root-비번-설정&quot;&gt;Root 비번 설정&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ubuntu를 깔고 사용자 등록 후 su 명령어를 통해 root로 전환하려는데 에러가 났다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su : Authentication failure
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;나의 경우 root 비밀번호 설정을 하지 않아서 나는 에러였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;root 비밀번호를 설정한다.&lt;/p&gt;

        &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;passwd root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Linux" /></entry><entry><title type="html">NAT이란? Static NAT, Dynamic NAT, PAT 비교</title><link href="http://localhost:4000/network/2021/01/07/NAT.html" rel="alternate" type="text/html" title="NAT이란? Static NAT, Dynamic NAT, PAT 비교" /><published>2021-01-07T00:00:00+09:00</published><updated>2021-01-07T00:00:00+09:00</updated><id>http://localhost:4000/network/2021/01/07/NAT</id><content type="html" xml:base="http://localhost:4000/network/2021/01/07/NAT.html">&lt;h1 id=&quot;nat&quot;&gt;NAT&lt;/h1&gt;

&lt;p&gt;NAT은 Network Address Translation의 약자로, 네트워크 주소를 변환해주는 방식이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;Network Address는 우리가 흔히 아는 IP주소라고 생각하면 되는데, 이러한 변환 방식이 생겨난 이유는 다음과 같다.&lt;/p&gt;

&lt;p&gt;IPv4방식으로 표현할 수 있는 주소 개수에는 한계가 있는데, 때문에 현대의 수많은 장비(PC, 스마트폰 등)들을 수용할 수없다.&lt;/p&gt;

&lt;p&gt;그렇다고 IPv6로 한번에 바꾸기에는 이미 IPv4를 사용하고 있는 수많은 서비스들에 장애가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 여러 대의 기기들을 하나의 로컬 망으로 묶고 로컬 망 내의 사설 IP를 공인 IP로 맵핑시켜주는 방식을 통해,&lt;/p&gt;

&lt;p&gt;적은 공인 IP를 더 많은 장비들이 사용할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;여기서, 사설 IP와 공인 IP를 맵핑해주는 방식을 NAT이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;static-nat&quot;&gt;Static NAT&lt;/h2&gt;

&lt;p&gt;공인IP와 사설IP를 1:1로 맵핑시켜준다.&lt;/p&gt;

&lt;p&gt;예를 들어, 192.168.0.20 이라는 사설 IP와 121.156.242.211이라는 공인 IP가 한번 맵핑 되면 192.168.0.20은 항상 121.156.242.211와 묶여있게 된다.&lt;/p&gt;

&lt;p&gt;공인 IP주소와 실제로 사용하는 장비의 개수가 1:1이기 때문에, 공인 IP주소를 아낄수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;dynamic-nat&quot;&gt;Dynamic NAT&lt;/h2&gt;

&lt;p&gt;공인IP와 사설IP를 1:1 맵핑 시켜주지만, 동적으로 맵핑되기 때문에 개념적으로 PC의 공인 IP는 고정되어 있지 않다.&lt;/p&gt;

&lt;p&gt;PC가 사용중이면 그 PC의 사설IP와 공인IP가 맵핑되어 있지만, PC가 사용중이지 않는다면 맵핑되어 있는 공인 IP가 반환되고,&lt;/p&gt;

&lt;p&gt;맵핑이 필요한 다른 PC가 해당 공인IP를 사용할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;이런 식으로 동적 할당해줌으로써 더 적은 공인IP로 여러 PC가 인터넷에 연결할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;patport-address-translation&quot;&gt;PAT(Port Address Translation)&lt;/h2&gt;

&lt;p&gt;공인IP 1개와 사설 IP여러개를 맵핑하여 사용할 수 있게 해주는데, 공인IP의 포트번호 별로 사설IP의 특정 포트에 맵핑해주는 방식이다.&lt;/p&gt;

&lt;p&gt;공유기에서 흔히 말하는 포트 포워딩이 이러한 방식이라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, 사설 IP가 192.168.0.1~10 이고 공인 IP가 121.156.242.211이라고 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;121.156.242.211:11 &amp;lt;=&amp;gt; 192.168.0.1:22&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;121.156.242.211:231 &amp;lt;=&amp;gt; 192.168.0.5:22&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;121.156.242.211:4000 &amp;lt;=&amp;gt; 192.168.0.3:900&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;121.156.242.211:3219 &amp;lt;=&amp;gt; 192.168.0.8:11&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;121.156.242.211:24442 &amp;lt;=&amp;gt; 192.168.0.10:22&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 식으로 맵핑하여 하나의 공인 IP로 여러 대의 PC를 사용할 수 있게 된다.&lt;/p&gt;</content><author><name></name></author><category term="Network" /><category term="NAT" /></entry></feed>