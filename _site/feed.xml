<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-28T11:53:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">21년 1월 27일</title><link href="http://localhost:4000/til/2021/01/27/TIL23.html" rel="alternate" type="text/html" title="21년 1월 27일" /><published>2021-01-27T00:00:00+09:00</published><updated>2021-01-27T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/27/TIL23</id><content type="html" xml:base="http://localhost:4000/til/2021/01/27/TIL23.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 비동기 프로그래밍 미션을 하루종일 했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;미션에서 주어진 역할을 클래스로 만들고 객체간의 메세지를 보내(메소드 실행) 이벤트를 발생하게 했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;객체 각자가 비동기적으로 일을 수행해, 주문을 받은 커피를 만들고 커피가 완료됐다고 출력하는 미션이었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만든 클래스는 다음과 같다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;주문을 받는 Cashier Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문 목록을 갖고있는 OrderList Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;OrderList를 보고 일을 할당해주는 Manager Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피를 만드는 Barista Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;완료된 목록을 출력해주는 DashBoard Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류인 CoffeeType Enum&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류와 주문한 고객정보를 갖고있는 Coffee Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문한 고객정보와 Coffee를 모두 담고 있는 Order Class&lt;/p&gt;

            &lt;p&gt;(고객1이 아메리카노2잔,카페라떼3잔을 시켰다면 커피1잔은 Coffee Class에 해당하고, 전체 주문 한건은 Order Class에 해당)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture에서 제공하는 runAsync나 supplyAsync를 사용하면 Executors로 직접 쓰레드풀을 생성할 필요가 없이,&lt;/p&gt;

        &lt;p&gt;ForkJoinPool에서 제공하는 쓰레드 풀에 Task를 할당할 수 있다. (매우 편리하다!)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture를 사용하면 콜백지옥없이 thenApplyAsync와 같은 메소드를 통해, promise패턴으로 구현이 가능하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;모든 주문이 완료된 상태에서 3초간 input이 들어오지 않으면 종료시킨다는 조건이 있었는데, io 블락중인 상태를 어떻게 종료해야할지 몰라서 정말 힘들었다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;io입력 받는 부분을 CompletFuture를 통해 non-block 상태로 실행시킨다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;future.getNow(null) 메소드를 통해 (task가 완료되면 리턴값을, 아직 진행중이면 null을 반환한다는 의미)&lt;/p&gt;

            &lt;p&gt;io로 input이 들어왔는지 판단한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;io로 input이 들어오지 않은 상태에서 모든 주문이 끝났고, 주문이 끝난지 3초 이상 지났으면 함수를 return해준다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;데몬 쓰레드에서 돌고있는 Scanner.nextLine()이 종료되지 않은 상태에서 메인 쓰레드가 종료되기 때문에, 프로세스가 종료된다.&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showMenu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//메뉴 목록 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showHowToOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문하는 방법 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문받기 시작했기 때문에, 주문이 완료된적 없음&lt;/span&gt;
       
        &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;supplyAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//listen값이 null이 아닌동안 계속 확인&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{};&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문완료, 3초 지났으면 종료&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;모든 메뉴가 완성되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;translateOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;올바른 형식을 입력해주세요.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;orderList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;미션이 생각보다 어려워서, 알고리즘 공부와 자바의정석 읽기를 못했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;생각보다 어려웠는데 새벽 3시까지 코딩해서 결국 다 만들었다 ㅎㅎ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;힘든 일이 있어서 멘붕이 왔었는데, 다시 회복하고 있다.&lt;/li&gt;
  &lt;li&gt;깨졌던 공부 루틴을 회복하기 시작해서 좋다.&lt;/li&gt;
  &lt;li&gt;CompleteFuture를 사용하니까 너무 편리하다. (내부 작동원리 등은 계속 써가면서 공부해야 할 것 같다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 26일</title><link href="http://localhost:4000/til/2021/01/26/TIL22.html" rel="alternate" type="text/html" title="21년 1월 26일" /><published>2021-01-26T00:00:00+09:00</published><updated>2021-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/26/TIL22</id><content type="html" xml:base="http://localhost:4000/til/2021/01/26/TIL22.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 단어변환 문제를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;단어변환:
        &lt;ol&gt;
          &lt;li&gt;간단한 BFS문제이다.&lt;/li&gt;
          &lt;li&gt;문제에서 주어진 규칙만 준수하여, visit체크와 함께 변환한 단어를 queue에 넣어준다.&lt;/li&gt;
          &lt;li&gt;queue에서 꺼낸 값이 target과 일치할 경우 변환한 개수를 반환하면 된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 처음으로 TIL도 쓰지 않고, 아무것도 하지 못했다.&lt;/li&gt;
  &lt;li&gt;오늘도 코드스쿼드 미션은 읽어보지도 못하고 울면서 알고리즘 한문제만 겨우 푼거같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 오늘 개인사정으로 인해 정말 오르락내리락 멘탈이 무너졌던 이틀이었다.&lt;/li&gt;
  &lt;li&gt;무슨일이 생겨도 꾸준히 하던 것을 놓으면 안되는데, 애초에 멘탈을 강하게 지켜야하는데 이번 일은 그게 좀 힘들었다.&lt;/li&gt;
  &lt;li&gt;내일부터 다시 제대로 열심히 꾸준히 해보려고한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking</title><link href="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html" rel="alternate" type="text/html" title="Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking" /><published>2021-01-25T00:00:00+09:00</published><updated>2021-01-25T00:00:00+09:00</updated><id>http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking</id><content type="html" xml:base="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html">&lt;h2 id=&quot;synchronous--asynchronous&quot;&gt;Synchronous / Asynchronous&lt;/h2&gt;

&lt;p&gt;Synchronous의 어원부터 살펴보면, Sync (함께) + Chrono(시간) 이 합쳐진 단어이다.&lt;/p&gt;

&lt;p&gt;즉, Synchronous란 ‘함께 시간을 맞춰 행동한다’고 해석할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, B라는 function을 사용하는 A라는 function이 있다고 해보자&lt;/p&gt;

&lt;p&gt;여기서 A는 호출한 자라고 할 수 있고, B는 호출받은 자라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;synchronous&quot;&gt;Synchronous&lt;/h3&gt;

&lt;p&gt;A는 B를 호출하게 되고, B가 종료되는 시점에 A가 그 다음 동작을 수행한다면 Synchronous라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하면 Synchronous인 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 시간을 맞춰 행동하면 코드의 작성 순서대로 실행된다는 것을 보장할 수 있게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 시작되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 끝났습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B입니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바는 기본적으로 Blocking / Synchronous한 언어이기 때문에, A() 메소드를 실행한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A가 시작되었습니다.&lt;/li&gt;
  &lt;li&gt;B입니다.&lt;/li&gt;
  &lt;li&gt;A가 끝났습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;순서로 출력이 될 것이다.&lt;/p&gt;

&lt;p&gt;Synchronous하기 때문에, B의 호출이 끝나는 시간과 A가 시작되는 시간이 일치하기 때문이다.&lt;/p&gt;

&lt;p&gt;다시 말하면, B의 호출이 끝난 후(“B입니다.” 출력) A가 다시 시작하여 (“A가 끝났습니다.”)를 출력하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;asynchrnous&quot;&gt;Asynchrnous&lt;/h3&gt;

&lt;p&gt;Asynchronous는 Synchronous에 반대를 뜻하는 접두사 A가 붙은 형태이다.&lt;/p&gt;

&lt;p&gt;즉, 시간을 맞추지 않는다고 생각하면 될 것이다.&lt;/p&gt;

&lt;p&gt;A가 B를 호출한 뒤, B의 종료여부를 신경쓰지 않고 다시 A가 작업을 재개하는 것을 생각하면된다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하지 않는 것이다.&lt;/p&gt;

&lt;p&gt;위의 예가 Asynchronous하게 동작한다면,&lt;/p&gt;

&lt;p&gt;A는 B를 호출한 후 B의 종료 시점을 기다리지 않고, “A가 끝났습니다.”를 출력하려고 할 것이다.&lt;/p&gt;

&lt;p&gt;따라서, “B입니다.”가 먼저 출력될지 “A가 끝났습니다.”가 먼저 출력될지 알 수 없게 된다.&lt;/p&gt;

&lt;p&gt;코드의 작성 순서대로 실행되는 것이 보장되지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;blocking--non-blocking&quot;&gt;Blocking / Non-Blocking&lt;/h2&gt;

&lt;p&gt;Blocking과 Non-Blocking을 설명하기 위해서 제어권이라는 용어가 많이 사용된다.&lt;/p&gt;

&lt;p&gt;간단하게, 제어권이란 스스로 동작할 수 있는 권리라고 이해하면 된다.&lt;/p&gt;

&lt;p&gt;A라는 함수에 제어권이 있다면 A는 현재 동작할 수 있는 상태인 것이다.&lt;/p&gt;

&lt;p&gt;Blocking / Non-Blocking은 이런 제어권의 반환이 언제 되느냐에 대한 관점이다.&lt;/p&gt;

&lt;h3 id=&quot;blocking&quot;&gt;Blocking&lt;/h3&gt;

&lt;p&gt;Blocking은 호출된 함수가 종료될 때까지 호출한 자에게 제어권을 넘겨주지 않는 것이다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;non-blocking&quot;&gt;Non-Blocking&lt;/h3&gt;

&lt;p&gt;Non-Blocking에서 호출된 함수는 제어권을 바로 호출한 함수에게 넘겨준다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하지 않는다.&lt;/p&gt;

&lt;p&gt;Non-Blocking 함수를 호출한다면, 호출자에게 제어권을 바로 반환하기 때문에,&lt;/p&gt;

&lt;p&gt;호출자는 자신의 동작을 진행할 수 있고, 호출된 함수도 자신의 동작을 진행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참고하기 매우 좋은 글&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&quot;&gt;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Synchronous" /><category term="Asynchronous" /><category term="Blocking" /><category term="Non-Bolocking" /></entry><entry><title type="html">21년 1월 24일</title><link href="http://localhost:4000/til/2021/01/24/TIL21.html" rel="alternate" type="text/html" title="21년 1월 24일" /><published>2021-01-24T00:00:00+09:00</published><updated>2021-01-24T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/24/TIL21</id><content type="html" xml:base="http://localhost:4000/til/2021/01/24/TIL21.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 12 지네릭스, 열거형, 애너테이션 중 지네릭스를 모두 읽었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭스는 클래스 또는 메소드에 타입을 파라미터처럼 전달하여(타입 변수) 타입을 보다 자유롭게 쓸 수 있게 해준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭스의 장점은 다음과 같다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;타입 안정성을 제공한다.&lt;/li&gt;
          &lt;li&gt;타입체크와 형변환을 생략할 수 있어 코드를 간소화해준다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭 메소드에 선언된 타입 변수와 지네릭 클래스에 선언된 타입 변수는 다르다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭 메소드에 선언된 타입 변수는 해당 메소드의 지역 변수와 같은 우선순위를 갖는다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;즉, 지네릭 클레스에 T라는 타입변수가 선언되어 있고, 지네릭 메소드에 T라는 타입변수가 있으면,&lt;/p&gt;

            &lt;p&gt;해당 메소드 내의 T는 지역변수나 마찬가지인 지네릭 메소드의 T를 의미한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;와일드 카드에 대해 배웠다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드는 ?로 정의되며 &amp;lt;?&amp;gt; 라는 건 &amp;lt;? extends Object&amp;gt;를 생략한 것이다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드는 참조변수 타입에 선언되는데,&lt;/p&gt;

            &lt;p&gt;&amp;lt;? extends Fruit&amp;gt;라면 해당 참조변수의 인스턴스에는 타입 변수로 Fruit와 Fruit를 상속한 클래스 타입이 들어갈 수 있고,&lt;/p&gt;

            &lt;p&gt;&amp;lt;? super Fruit&amp;gt;일 경우에는 타입 변수로 Fruit와 Fruit가 상속한 부모 클래스 타입이 들어갈 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드로 선언된 참조변수 간에는 컴파일러가 판단하여 형변환을 할 수 있게 해준다.&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;Fruit와 Fruit를 상속 받은 Apple, Grape가 있다고 하자.&lt;/p&gt;

                &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 에러;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 에러; &lt;/span&gt;
         
&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//경고; fruitList는 Apple로 형변환할 수 있는 타입이 들어갈수도 있으므로 에러로 막지는 않음&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//성공; appleList는 Fruit로 형변환할 수 있는 타입이 들어가있으므로 경고하지 않음&lt;/span&gt;
         
&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//에러; grapeList는 Apple로 형변환할 수 있는 타입이 들어갈 수 없으므로 에러&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//에러; appleList는 grape로 형변환할 수 있는 타입이 들어갈 수 없으므로 에러&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 타겟넘버, 네트워크 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;타겟넘버:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;간단한 DFS/BFS문제이다.&lt;/li&gt;
          &lt;li&gt;주어진 숫자들을 +또는 -로 연산해가면서 마지막에 target과 같을 경우 경우의 수를 늘려준다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;네트워크:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;DFS/BFS로 풀수도 있고, union-find알고리즘으로 풀 수도 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;두 가지 방법으로 모두 풀어봤다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;union-find의 경우는 computers매개변수를 순회하며 1인경우 두 노드를 하나의 집합으로 만들어준다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;마지막에 parent 배열을 순회하며 각 parent배열 값을 다시 getParent(parent[n])로 확인하여 HashSet(집합 명 Set)에 넣어준다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;HashSet의 size가 네트워크 개수가 된다.&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DFS/BFS로 푸는 방법은 그냥 areaNum을 늘려주며 area가 정해지지 않은 node의 area를 DFS/BFS로 areaNum으로 정해준다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기라는 목표를 점점 뒤로 미루고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주말이라 쉬엄쉬엄했지만 꾸준함의 중요성을 인지하며 공부하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;제너릭스는 생각보다 어렵지 않았다.&lt;/li&gt;
  &lt;li&gt;자바 API를 읽을때마다 헷갈렸던 ?라는 와일드카드를 알게되어서 기분이 좋았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;자바의 정석 열거형 읽기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더 쉽게는 자바의 정석 1회독 한 후 읽어야 할 것 같다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 23일</title><link href="http://localhost:4000/til/2021/01/23/TIL20.html" rel="alternate" type="text/html" title="21년 1월 23일" /><published>2021-01-23T00:00:00+09:00</published><updated>2021-01-23T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/23/TIL20</id><content type="html" xml:base="http://localhost:4000/til/2021/01/23/TIL20.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 13 쓰레드 (9.쓰레드의 동기화 ~ 끝) 모두 읽었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;synchronized를 이용한 동기화를 배웠다.
        &lt;ul&gt;
          &lt;li&gt;synchornized method와 synchronized block을 이용한 critical section 생성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특정 객체가 Lock을 너무 오래 갖는 것을 방지하기 위한 wait와 notify의 사용법을 배웠다.&lt;/li&gt;
      &lt;li&gt;JDK1.5부터 추가된 java.util.concurrent.locks 패키지 사용법을 배웠다.
        &lt;ul&gt;
          &lt;li&gt;ReetrantLock, ReetrantReadWriteLock, StampedLock 사용법&lt;/li&gt;
          &lt;li&gt;StampedLock은 ReetrantReadWriteLock에 optimisticLock이 추가된 Lock이다.
            &lt;ul&gt;
              &lt;li&gt;optimisticReadLock은 사용하면 바로 lock을 얻지만, 누군가 쓰기 lock을 얻는다면 바로 무효화된다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;await(), signal()은 synchronized의 wait(), notify()와 대응된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;volatile 키워드가 무엇인지 알게 되었다.
        &lt;ul&gt;
          &lt;li&gt;변수를 원자화한다.
            &lt;ol&gt;
              &lt;li&gt;JVM은 4바이트 단위로 처리하기 때문에, long이나 double 타입은 한번에 읽을수 없다.&lt;/li&gt;
              &lt;li&gt;volatile키워드로 선언하면 long이나 double도 다른 쓰레드의 침범 없이 원자화하여 읽을 수 있다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;항상 메모리에서 값을 가져온다.
            &lt;ol&gt;
              &lt;li&gt;멀티 코어에서는 각 코어가 캐시에 저장된 변수를 참조할 수도 있다.&lt;/li&gt;
              &lt;li&gt;즉, 1번 코어에서 메모리에 변수를 바꿔도, 2번 코어는 캐시의 변수를 참조하고 있으면 정상 동작하지 않는다.&lt;/li&gt;
              &lt;li&gt;이를 방지하기 위해서 volatile 키워드로 변수를 선언하여 항상 메모리에서 값을 읽도록 강제해준다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 정수삼각형, 등굣길을 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;정수삼각형:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;dp 문제 같긴한데, 그냥 iterative하게 푸는게 더 편하고 빠르다.&lt;/li&gt;
          &lt;li&gt;삼각형의 위층부터 내려오며 각 위치까지 오는데 가장 큰 값들을 계산해서 넣어준다.&lt;/li&gt;
          &lt;li&gt;삼각형의 맨 마지막 층에 각 위치별로 오는데 가장 큰 값이 저장되어 있을 것이다.&lt;/li&gt;
          &lt;li&gt;마지막 층에 저장된 값중 가장 큰 값을 반환한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;등굣길:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;전형적인 dp문제이다.&lt;/li&gt;
          &lt;li&gt;(x,y)의 길의 개수는 (x-1,y)+(x,y-1)가 된다.&lt;/li&gt;
          &lt;li&gt;m,n 크기일 때, cache배열을 3차원 &lt;code class=&quot;highlighter-rouge&quot;&gt;new int[m][n][2]&lt;/code&gt; 으로 하는 것이 핵심이다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache[x][y][0]&lt;/code&gt; 에는 (x,y)값이 계산이 끝났는지(1), 물 웅덩이인지(-1), 아직 계산이 안됐는지(0)가 저장된다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache[x][y][1]&lt;/code&gt; 에는(x,y)값의 계산이 끝났을 경우 (x,y)값이 저장된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;등굣길 문제를 풀 때, input으로 들어온 x,y좌표 기준과 내가 정의한 x,y좌표 기준이 틀려서 해멨다.
    &lt;ul&gt;
      &lt;li&gt;문제에서 (1,1)은 내가 설계한 코드에서는 (0,0)을 의미하기 때문에 x,y모두 1씩 빼줘야했다 ㅠㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 문제였으면 테스트케이스까지만 확인하고 냈으므로 틀렸을 것이다.&lt;/li&gt;
  &lt;li&gt;아주 사소한 문제인데, 또 실수를 해버려서 아쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석을 계획한 데로 읽었다.&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 2문제나 풀었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석 쓰레드는 운영체제 지식이 없으면 읽기 어려웠을 것 같다.&lt;/li&gt;
  &lt;li&gt;그래도 이해하면서 쓰레드 챕터를 완독할 수 있어서 아주 뿌듯했다.&lt;/li&gt;
  &lt;li&gt;다 외우는게 목적이 아니기 때문에, 이해만으로 넘어가고 앞으로 코딩할때 참고용으로 자주 봐야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
  &lt;li&gt;자바의 정석 제너릭스 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 22일</title><link href="http://localhost:4000/til/2021/01/22/TIL19.html" rel="alternate" type="text/html" title="21년 1월 22일" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/22/TIL19</id><content type="html" xml:base="http://localhost:4000/til/2021/01/22/TIL19.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 프로세스의 시뮬레이션을 설계 및 구현해보았다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;CPU class를 만들어서 그 CPU는 항상 자신에게 올라온 Process를 Run하는 역할만 맡겼다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CPU는 무한루프를 돌면서 자신의 Process의 run 메소드를 실행하는데, run 메소드는 Process 클래스를 반환해서&lt;/p&gt;

        &lt;p&gt;다음으로 돌릴 Process는 계속 변하게 설계하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Process class를 상속받는 UserProcess(유저모드), KernelProcess(커널모드)를 만들었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UserProcess는 public Process run() 메소드를 통해 실행되게 되는데, run 한 번에 1tick으로&lt;/p&gt;

        &lt;p&gt;Timer Interrupt가 걸린다고 가정하고 구현하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UserProcess의 run메소드 마지막에 항상 자신이 갖고있는 KernelProcess의 TrapNumber를&lt;/p&gt;

        &lt;p&gt;Timer interrupt로 지정해주고 자신의 KernelProcess를 반환하게 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CPU에서는 반환된 KernelProcess의 run을 실행하게 되어 커널 모드로 진입하고 TrapNumber가&lt;/p&gt;

        &lt;p&gt;Timer interrupt라면 scheduler를 실행하여 다음으로 실행할 UserProcess를 반환한다.&lt;/p&gt;

        &lt;p&gt;(사실은 다음 Process의 Kernel모드를 반환후 다음 Process의 커널에서 유저모드로 전환해야 하는데,&lt;/p&gt;

        &lt;p&gt;구현상 너무 어려워서 하지 않았다.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 13 쓰레드 - 8. 쓰레드의 실행제어까지 읽었다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;서로 관련된 Thread를 그룹으로 묶기 위한 ThreadGroup이 있고,&lt;/p&gt;

        &lt;p&gt;ThreadGroup이 생성될때 어떤 규칙으로 생성되는지 알게 되었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;suspend(), stop(), resume() 등이 동기화, 교착상태 등에서 문제를 발생할 수 있어&lt;/p&gt;

        &lt;p&gt;deprecated 되었다는 것을 알게 되었고, 이를 대체하기 위한 설계 구조를 배웠다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;interrupt()와 yield()를 이용해 좀더 반응성이 좋은 Thread를 설계하는 법을 배웠다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 N으로 표현 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;N으로 표현:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;dp문제였는데, dp라는 개념을 다 까먹어서 답 코드를 보고 복기하였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;모든 경우의 수를 생각하기 때문에 언뜻 dfs, bfs랑 비슷해 보일 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;그러나 경우를 잘게 쪼개서 (n+2의 경우) = (n+1의 경우와 n의 경우의 조합)와 같이&lt;/p&gt;

            &lt;p&gt;점화식을 구해서 모든 경우의 수를 쉽게 구할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;특히 한번 n의 경우를 구했으면 cache 구조체에 저장하여,&lt;/p&gt;

            &lt;p&gt;다음부터 n의 경우는 cache에서 바로 반환 있어야 시간초과가 나지 않을 것이다 (메모이제이션)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;N으로 최소 갯수만큼 써서, number를 만들어야 한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;기본적으로 N을 x번 써서 만들 수 있는 number는 NNN..(x번)이 존재한다.(기본숫자)&lt;/p&gt;

            &lt;p&gt;(ex: 9를 3번 써서 만들 수 있는 number에는 999가 포함된다.)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;따라서 N을 x번 써서 만들 수 있는 숫자는 (기본숫자) + (1번 쓰는 경우와 N-1번 쓰는 경우의 조합) +&lt;/p&gt;

            &lt;p&gt;(2번 쓰는 경우와 N-2번 쓰는 경우의 조합) + … + (N-1번 쓰는 경우와 1번 쓰는 경우의 조합)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;금요일이라고 일찍 쉬지 않고, 자바의 정석 읽기 + 코테연습 모드 진행하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석을 제대로 읽기 시작했는데, 자바에서 쓰레드를 쓰는 좋은 팁이 있었다. 정말 좋은 책 같다.&lt;/li&gt;
  &lt;li&gt;dp를 애매하게 알고 있어서 찜찜했는데 드디어 복습을 시작했다.&lt;/li&gt;
  &lt;li&gt;꾸준히 하면 언젠가 늘겠지, dp도 쉽게 느껴지는 날이 오기를&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
  &lt;li&gt;자바의 정석 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">싱글코어에서도 Thread를 늘리면 빨라질까?</title><link href="http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread.html" rel="alternate" type="text/html" title="싱글코어에서도 Thread를 늘리면 빨라질까?" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread</id><content type="html" xml:base="http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread.html">&lt;h2 id=&quot;싱글코어-cpu-한-개라서-실질적으로-한번에-한-개만-실행할-수-있다고-가정&quot;&gt;싱글코어 CPU 한 개라서, 실질적으로 한번에 한 개만 실행할 수 있다고 가정&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;여기서 덧셈을 하는 300개의 쓰레드를 생성해 돌린다고 가정해보자.&lt;/li&gt;
  &lt;li&gt;커널 레벨 쓰레드라면, 나의 Task(프로세스, 쓰레드 등 스케줄링해야 하는 작업 단위)가 많아진다.&lt;/li&gt;
  &lt;li&gt;다른 프로세스도 돌아가고 있을 것이므로, 쓰레드를 늘린 프로세스(나)의 CPU 점유율이 높아져서 내 속도가 빨라진다.&lt;/li&gt;
  &lt;li&gt;즉, 다른 프로세스도 돌아가고 있고, 커널 레벨 쓰레드라면, 나의 CPU점유율이 높아져서 속도가 빨라진다.&lt;/li&gt;
  &lt;li&gt;물론, 쓰레드 너무 많이 만든다면 오버헤드가 더 커져서 느려지게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;요약:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;멀티 프로세스 환경에서 다른 프로세스가 돌아가고 있을 때, 커널 레벨 쓰레드를 늘린다면 프로세스 속도는 빨라진다.&lt;/p&gt;

        &lt;p&gt;(CPU 점유율이 높아지기 때문에)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로세스가 딱 하나만 돌아가고 있거나, 유저 레벨 쓰레드를 늘린다면 오버헤드 때문에 프로세스 속도는 느려진다.&lt;/p&gt;

        &lt;p&gt;(유저 레벨 쓰레드는 프로세스 내에서 쓰레드 스케줄링할 뿐, 운영체제는 프로세스 하나로 보기 때문에 점유율이 높아지지 않는다.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="OS" /><category term="Process" /><category term="Thread" /></entry><entry><title type="html">21년 1월 21일</title><link href="http://localhost:4000/til/2021/01/21/TIL18.html" rel="alternate" type="text/html" title="21년 1월 21일" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/21/TIL18</id><content type="html" xml:base="http://localhost:4000/til/2021/01/21/TIL18.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스와 스레드의 차이점에 대해 공부하였다.&lt;/li&gt;
  &lt;li&gt;프로세스는 메모리에 적재하여 실행가능한 상태의 작업 단위이다.
    &lt;ul&gt;
      &lt;li&gt;스레드는 프로세스에 할당된 메모리 자원을 이용하여 실행되는 프로세스 내의 독립 실행 흐름이다.&lt;/li&gt;
      &lt;li&gt;스레드 간의 Context Switch는 레지스터 값과 Stack Pointer만 변경하면 되기 때문에 Process의 Context switch보다 빠르다.&lt;/li&gt;
      &lt;li&gt;스레드는 Stack영역 이외의 공간을 공유하기 때문에, 스레드 간의 통신이 쉽다.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/os/2021/01/21/Process_vs_Thread.html&quot;&gt;Process vs Thread&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OperatingSystem Three Easy Pieces 책을 80 page까지 읽었다.
    &lt;ul&gt;
      &lt;li&gt;운영체제의 주요 컨셉인 CPU 가상화, 메모리 가상화, 동시 실행, 영속성을 배웠다.&lt;/li&gt;
      &lt;li&gt;프로세스가 실행되는 과정을 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 모드로의 전환과 프로세스 간의 컨텍스트 스위치 과정에 대해 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 권한과 이에 따른 시스템 콜, 트랩 핸들러에 대해 배웠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 불량 사용자, 단속카메라를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;불량 사용자:
        &lt;ul&gt;
          &lt;li&gt;처음에 쉽게 접근했다가 복잡하다는 것을 깨달았다.&lt;/li&gt;
          &lt;li&gt;DFS로 풀었는데, HashSet을 남발하여 다소 찜찜하다.&lt;/li&gt;
          &lt;li&gt;DFS안에 현재까지의 불량 사용자 목록을 HashSet으로 담는다.&lt;/li&gt;
          &lt;li&gt;모든 밴 리스트를 참고하여 HashSet을 완성했으면 HashSet의 HashSet에 추가하여 중복을 제거한다.&lt;/li&gt;
          &lt;li&gt;HashSet의 HashSet의 size()가 정답의 개수가 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단속카메라:
        &lt;ul&gt;
          &lt;li&gt;Greedy 문제였다.&lt;/li&gt;
          &lt;li&gt;구현은 매우 쉬운데 아이디어를 떠올리는게 정말 어려웠다.&lt;/li&gt;
          &lt;li&gt;각 Route의 end 지점을 기준으로 오름차순 정렬을 한다.&lt;/li&gt;
          &lt;li&gt;end 지점을 기준으로 오름차순 정렬했기 때문에, 자신이 설치해야 하는 최선의 경우는 자신의 end지점에 설치하는 것이다.&lt;/li&gt;
          &lt;li&gt;정렬한 Routes를 순회하다가, 마지막에 설치한 카메라가 자신의 범위 안에 없으면, 자신의 end 위치에 카메라를 설치한다.
            &lt;ul&gt;
              &lt;li&gt;마지막에 설치한 카메라가 자신의 범위 안에 없으면 자신은 카메라를 안지나치는 것이다.&lt;/li&gt;
              &lt;li&gt;그 이유는 end를 기준으로 오름차순 정렬했고 이것을 순회하며 카메라를 설치하기 때문이다.&lt;/li&gt;
              &lt;li&gt;마지막에 설치한 카메라는 항상 설치된 카메라 중 제일 뒤쪽에 있는 카메라이다.&lt;/li&gt;
              &lt;li&gt;따라서 앞에 설치한 카메라가 자신의 범위 안에 있는데, 마지막 설치한 카메라가 자신의 범위 안에 없을 경우는 없다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;OS를 오랜만에 복습하고, 글로 정리하여 포스팅하였다.&lt;/li&gt;
  &lt;li&gt;레벨 3 카카오 문제를 한번에 풀었다 (80분 걸림)&lt;/li&gt;
  &lt;li&gt;greedy문제를 끈질기게 생각해서 해결방법을 알아냈다 (50분 걸림)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;오랜만에 OS를 복습했는데, 생각보다 까먹은게 많아서 아쉬웠다.(3학년때 정말 열심히 했는데 ㅠㅠ)&lt;/li&gt;
  &lt;li&gt;그래도 빠르게 읽고 다시 기억할 수 있어서 공부하길 잘했다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;카카오 문제 풀긴 했는데 HashSet의 HashSet을 쓴게 찜찜하여 다른 사람은 어떻게 풀었는지 참고해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Process와 Thread</title><link href="http://localhost:4000/os/2021/01/21/Process_vs_Thread.html" rel="alternate" type="text/html" title="Process와 Thread" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>http://localhost:4000/os/2021/01/21/Process_vs_Thread</id><content type="html" xml:base="http://localhost:4000/os/2021/01/21/Process_vs_Thread.html">&lt;h2 id=&quot;process-란&quot;&gt;Process 란&lt;/h2&gt;

&lt;p&gt;일반적으로 Process는 프로그램을 실행시킨 상태라고도 하고, 실행중인 프로그램이라고도 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 실행중이라는 상태는 구체적으로 어떤 모양일까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로그램은 디스크에 저장된 정적 데이터와 코드의 모임일 뿐이다.&lt;/p&gt;

&lt;p&gt;프로그램이 프로세스로 실행되는 과정을 간단하게(?) 설명하면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;운영체제는 프로그램의 코드와 정적 데이터를 프로세스의 메모리 공간(Code와 Data 영역)에 적재한다.&lt;/li&gt;
  &lt;li&gt;main함수를 찾아 CPU의 PC(Program Counter) 레지스터에 실행할 코드의 메모리 주소를 저장한다.&lt;/li&gt;
  &lt;li&gt;프로그램 실행 시 입력했던 Argument와 함께 Stack 영역을 구성한다.&lt;/li&gt;
  &lt;li&gt;프로세스가 사용할 Heap영역의 메모리를 할당한다.(Heap 영역은 동적 할당을 위해 사용된다.)&lt;/li&gt;
  &lt;li&gt;PC 레지스터가 가리키는 명령를 실행하기 위해, 데이터를 메모리로부터 읽어 레지스터에 저장한다.&lt;/li&gt;
  &lt;li&gt;레지스터에 저장한 값을 읽어 ALU가 명령에 따라 계산하고, 이 값을 다시 결과값 레지스터에 저장한다.&lt;/li&gt;
  &lt;li&gt;레지스터에 저장된 결과값을 다시 메모리에 저장한다.&lt;/li&gt;
  &lt;li&gt;PC 레지스터의 값을 증가시켜 다음 명령을 실행할 준비를 한다.&lt;/li&gt;
  &lt;li&gt;(5)~(8)이 반복되며 프로세스가 진행된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런식으로 프로세스는 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, Process란 디스크에 저장되어 있던 코드뭉치를 메모리에 적재하여 실행 가능하게 한 상태라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;context-switch&quot;&gt;Context Switch&lt;/h2&gt;

&lt;p&gt;일반적으로 OS는 마치 CPU 여러대가 있는 것처럼 착각할 수 있도록, 시분할 기법을 사용하여 프로세스들을 실행시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 프로세스가 3개 있다고 했을 때, 1번을 아주 조~금 실행한 후, 2번을 아주 조~금 실행한 후,&lt;/p&gt;

&lt;p&gt;3번을 아주 조~금 실행하는 방식을 통해 모든 프로세스가 동시에 진행되는 것처럼 느끼게 해준다.&lt;/p&gt;

&lt;p&gt;(어떤 순서로 돌아가며 프로세스를 실행시킬 지는 스케줄러 정책에 따라 다르다.)&lt;/p&gt;

&lt;p&gt;마치 CPU가 여러대 있는 것처럼 느끼게 해주는 것인데, 이렇게 하기 위해선 Context Switch가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Context란 아주 간단하다. Process가 실행되던 그 상황을 의미한다.&lt;/p&gt;

&lt;p&gt;1번 프로세스를 그 상황 그대로 멈추게 한 후, 마찬가지로 멈춰 있던 2번 프로세스를 실행시켜줘야 하고,&lt;/p&gt;

&lt;p&gt;다시 1번 프로세스를 실행할 시간이 되면 멈췄던 그 상황 그대로 되살려서 실행해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 그 ‘상황’(Context)는 어떻게 저장할까?&lt;/p&gt;

&lt;p&gt;위에서 설명한 Process를 통해 유추해볼 수 있는데,&lt;/p&gt;

&lt;p&gt;프로세스가 사용하던 Memory 주소와 레지스터값들을 저장하면 된다!&lt;/p&gt;

&lt;p&gt;(Memory 주소를 저장하는 이유는 메모리 가상화와 관련된 내용인데 지금은 다루지 않겠다.)&lt;/p&gt;

&lt;p&gt;(이 외에도 pid, process state, open files 등 저장할 값들이 있지만 생략하겠다. )&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그 상황에 사용하던 레지스터 값(PC를 포함한)들을 다시 CPU의 레지스터에 올리게 되면,&lt;/p&gt;

&lt;p&gt;다시 PC에 저장된 메모리 주소를 읽어 명령을 실행함으로써, 정지되었던 그 상황에서 실행하는 것이 가능해진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 context를 저장하는 구조체를 PCB(Process Control Block) 이라고 하는데,&lt;/p&gt;

&lt;p&gt;실행중인 Process의 PCB를 메모리에 저장한 후, 다음 실행할 Process의 PCB를&lt;/p&gt;

&lt;p&gt;메모리에서 읽어(CPU 레지스터에 올려) 실행하는 것을 Context Switch라고 한다.&lt;/p&gt;

&lt;p&gt;(User mode, kernel mode 간의 switch 등 많은 과정이 생략되었으니, 자세히 알고 싶으면 관련 내용을 찾아보기 바란다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread-란&quot;&gt;Thread 란&lt;/h2&gt;

&lt;p&gt;Thread는 Process에 종속된 개념으로 실제로 작업을 수행하는 주체라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;위 설명에서 Process가 실행될 때 main함수를 찾아 PC에 저장해주고 Stack 프레임을 구성해준다고 했는데,&lt;/p&gt;

&lt;p&gt;이것은 프로세스의 시작이라고 할 수도 있지만, 메인 쓰레드의 시작이라고 할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쓰레드는 각각 레지스터 셋(PC를 포함한)과 Stack프레임을 갖고 있어서,&lt;/p&gt;

&lt;p&gt;한 프로세스이지만 각각의 쓰레드가 독립적으로 명령을 수행하는 것처럼 보이게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;어? 위에서 설명한 Context Switch를 보면, 레지스터 셋은 Context고 이걸 각각 갖고 있으면 Process가 아닌가?&lt;/p&gt;

&lt;p&gt;라고 생각할 수 있지만, 가장 큰 차이점은 같은 Process의 쓰레드는 메모리 공간을 공유한다는 것이다.&lt;/p&gt;

&lt;p&gt;쓰레드는 레지스터셋과 Stack프레임을 각각 갖고 있지만, 프로세스의 Code, Data, Heap 메모리 공간을 공유한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;따라서 쓰레드간의 Context switch에서는 쓰레드가 사용할 메모리 주소값을 교체할 필요가 없고,&lt;/p&gt;

&lt;p&gt;레지스터 값과 Stack Pointer만 교체하면 되므로 Context Switch의 오버헤드가 프로세스보다 훨씬 적다.&lt;/p&gt;

&lt;p&gt;뿐만 아니라, Data나 Heap 영역을 공유하므로 쓰레드 간의 데이터 공유도 가능하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process끼리는 Memory Protection 정책에 의해 같은 메모리로 접근이 불가능하다.&lt;/p&gt;

  &lt;p&gt;Process끼리는 시스템에서 제공하는 IPC(Inter Process Communication)으로만 통신 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;요약-process-vs-thread&quot;&gt;요약 (Process vs Thread)&lt;/h1&gt;

&lt;p&gt;프로세스: 운영체제로부터 메모리를 할당받아 실행할 수 있게된 작업의 단위 (메모리에 올라간 프로그램)&lt;/p&gt;

&lt;p&gt;스레드: 프로세스가 할당받은 메모리를 이용하는 실행 흐름의 단위 (프로그램을 실행하는 독립적인 실행 흐름)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Thread의 장점:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쓰레드 간의 Context Switching이 프로세스 간의 Context Switching보다 빠르다.&lt;/li&gt;
  &lt;li&gt;Stack을 제외한 메모리 자원을 공유하고 있어서, 쓰레드 간의 통신이 프로세스 간의 통신보다 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thread의 단점:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Process의 자원을 공유하기 때문에, 쓰레드 중 하나에 문제만 생겨도 Process가 종료되고, 따라서 전체 쓰레드도 종료된다.&lt;/p&gt;

    &lt;p&gt;※ 자바에서는 메인 쓰레드가 종료되어도 돌고 있는 쓰레드가 있으면 Process가 종료되지 않는다.&lt;/p&gt;

    &lt;p&gt;​	즉, 모든 쓰레드가 종료되어야 Process가 종료되기 때문에 쓰레드 중 하나에 문제가 생겨도 다른 쓰레드는 잘 돌아간다.&lt;/p&gt;

    &lt;p&gt;​	(정확히는 데몬 쓰레드를 제외한 일반 쓰레드 모두가 종료되어야 Process가 종료된다.)&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stack을 제외한 메모리 자원을 공유하고 있어서, 프로그램 설계와 디버깅이 어렵다.&lt;/p&gt;

    &lt;p&gt;(동시에 같은 변수에 접근할 수 있기 때문에 동기화(Synchronization), 교착상태(deadlock)를 고려한 설계가 필요하다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="OS" /><category term="Process" /><category term="Thread" /></entry><entry><title type="html">21년 1월 20일</title><link href="http://localhost:4000/til/2021/01/20/TIL17.html" rel="alternate" type="text/html" title="21년 1월 20일" /><published>2021-01-20T00:00:00+09:00</published><updated>2021-01-20T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/20/TIL17</id><content type="html" xml:base="http://localhost:4000/til/2021/01/20/TIL17.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스의 크레인 인형뽑기 게임, 이상한 문자 만들기, 구명보트, 섬 연결하기를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;크레인 인형뽑기 게임:
        &lt;ul&gt;
          &lt;li&gt;주어진 규칙에 맞게 구현만 하면 되는 레벨1짜리 문제였다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이상한 문자 만들기:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;마찬가지로 주어진 구현만 하면 되는 쉬운 문제였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;하지만 문제를 자의적으로 해석해 틀리고 말았다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;공백으로 구분된 문자들을 기준으로 짝수번째는 대문자 홀수번째는 소문자로 바꾸는 문제였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;쉬운 문제였는데 틀리고 말았다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;나는 자의적으로 해석하여, 공백을 기준으로 단어를 split한 후 대문자,소문자를 적용하고나서 다시 공백으로 합쳤다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;문제에서 각 문자들이 공백 하나로만 구분된다거나 맨마지막 단어 뒤에 공백이 없다는 조건이 없었다.&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;문제를 제대로 읽고, 문제에서 제약조건으로 알려주지 않은 모든 경우의 수를 생각하며 풀어야 한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구명보트:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;풀었던 문제인데도 효율성에서 시간초과가 나서 결국 답을 보고 풀었다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;무게순으로 정렬 후 순회하며 풀어나가는 문제이다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;순회하는 기준을 어디로 두냐의 문제였다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;무게가 작은 사람을 기준으로 순회한다면, 같이 보트를 태울 사람을 최대무게부터&lt;/p&gt;

                &lt;p&gt;현재 무게 더해도 한계를 안넘는 사람을 찾을 때까지 줄여나가며 찾아야 한고 못 찾으면 현재 무게만 태운다.&lt;/p&gt;

                &lt;p&gt;(모든 사람의 무게가 limit인 경우 항상 이중포문을 돌게 된다.)&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;무게를 큰 사람을 기준으로 순회한다면, 같이 보트를 태울 사람을 찾을 때, 최소무게+현재무게가 한계를 안넘으면 태우고,&lt;/p&gt;

                &lt;p&gt;한계를 넘으면 현재 무게만 보트에 태우면 된다.(무게가 큰 사람부터 순회하기 때문)&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;시간초과가 나는 것을 보고, 도저히 해결못하겠다고 생각했는데 기준만 다르게 생각하면 되는 문제였다 ㅠㅠ&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;섬 연결하기:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;그냥 크루스칼 알고리즘으로 풀라고 던져준 문제 같았다.&lt;/li&gt;
          &lt;li&gt;union-find 기법과 kruskal 알고리즘으로 간단하게 풀 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한달의 중간을 안쉬고 달렸다는 핑계로 쉬는 시간이 많았다.&lt;/li&gt;
  &lt;li&gt;책을 아예 안보고 있다. 조금이라도 전진하는 것과 멈추는 것은 다른 문제인데..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;그래도 오늘 하기로 계획한 알고리즘 문제는 모두 풀었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;완독하기로 한 책을 조금씩이라도 읽어야 발전하는데 아예 진행을 안하고 있다.&lt;/li&gt;
  &lt;li&gt;진짜 고질적인 문제인데, 계획한 시간을 넘으면 잠시 멈추고 하기로 한 일을 진행해야 한다.&lt;/li&gt;
  &lt;li&gt;걱정이 많이 된다. 쉴 땐 쉬고 할 땐 하는 연습이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry></feed>