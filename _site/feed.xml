<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-02-02T23:39:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">21년 2월 2일</title><link href="http://localhost:4000/til/2021/02/02/TIL.html" rel="alternate" type="text/html" title="21년 2월 2일" /><published>2021-02-02T00:00:00+09:00</published><updated>2021-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/02/02/TIL</id><content type="html" xml:base="http://localhost:4000/til/2021/02/02/TIL.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션: 소켓 통신을 사용하여 HttpRequest와 HttpResponse 객체 구현하기&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;URL 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;URL 객체를 생성할 때, url string값을 인자로 넣어준다.&lt;/li&gt;
          &lt;li&gt;생성자에서 url을 파싱하여 protocol, domain, path, port를 프로퍼티로 저장한다.&lt;/li&gt;
          &lt;li&gt;생성자에서 InetAddress를 사용하여 DNS서버로부터 호스트 IP를 받아온다(DNS Look up)&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HttpRequest 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;URL 객체를 인자로 생성할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Request메소드에 [GET, POST, UPDATE, DELETE] Method값(enum)과 body(JsonObject)를 넣어준다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;인스턴스의 URL과 인자로 받은 Method값, body를 조합하여 기본적인 Http 요청 String을 만든다.&lt;/li&gt;
              &lt;li&gt;URL의 IP와 포트번호를 기준으로 Socket 연결한다.&lt;/li&gt;
              &lt;li&gt;Socket 통신을 통해 만들어놓은 Http 요청을 보낸다.&lt;/li&gt;
              &lt;li&gt;Socket으로 들어온 Response를 BufferedReader로 읽으며 HttpResponse를 생성한다.
                &lt;ul&gt;
                  &lt;li&gt;처음 등장하는 빈 줄을 기준으로 header와 body를 나눈다.&lt;/li&gt;
                  &lt;li&gt;response header에 Content-Length가 있으면 Content-Length개 만큼 body를 읽는다.&lt;/li&gt;
                  &lt;li&gt;Content-Length가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;값이 나올때까지 body를 읽는다.&lt;/li&gt;
                  &lt;li&gt;다 읽으면 바로 socket 연결을 끊는다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;생성한 HttpResponse를 반환한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HttpResponse 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;header String(포맷에 맞아야 함)과 body String을 파라미터로 생성할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;그냥 생성할 경우, setHeader(String header) 와 setBody(String body)로 Response를 만들어줘야한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;header String 을 파싱하여 protocol, statusCode, statusMessage를 생성하며, 나머지 헤더값은&lt;/p&gt;

            &lt;p&gt;Map&amp;lt;String, String&amp;gt; 형태로 저장한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 보석쇼핑 문제 풀기에 실패했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HashSet을 이용하여 보석 종류의 개수를 구한다.&lt;/li&gt;
      &lt;li&gt;기본적으로 길이가 j 인 구간에서 모든 종류가 있는지 확인할 땐 sliding window기법을 사용했다.
        &lt;ol&gt;
          &lt;li&gt;HashMap&amp;lt;String, Integer&amp;gt;을 사용한다.&lt;/li&gt;
          &lt;li&gt;1번째부터 j번째까지 돌며 HashMap에서 보석의 value를 1씩 증가시킨다.&lt;/li&gt;
          &lt;li&gt;HashMap의 크기가 보석종류의 개수와 같으면 현재 구간을 반환한다.&lt;/li&gt;
          &lt;li&gt;j+1번째부터 마지막까지 순회하며
            &lt;ol&gt;
              &lt;li&gt;직전 구간 첫번째 보석의 value를 1 감소시키고, value가 0이면 HashMap에서 삭제한다.&lt;/li&gt;
              &lt;li&gt;새로 포함된 보석의 value를 1 증가시킨다.&lt;/li&gt;
              &lt;li&gt;HashMap의 크기가 보석종류의 개수와 같으면 현재 구간을 반환한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;끝까지 답을 못찾으면 null을 반환한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;정답 구간의 길이 최대값은 gems의 개수, 최소값은 보석종류의 개수이다.&lt;/li&gt;
      &lt;li&gt;binarySearch로 정답 구간의 길이를 찾아가며 최소 길이의 구간을 찾아낸다.&lt;/li&gt;
      &lt;li&gt;효율성에서 1개 빼고 모두 실패하였다. 방법 자체를 다시 생각해봐야겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;미션을 아주 만족스럽게 끝낼 수 있었다!!&lt;/li&gt;
  &lt;li&gt;네트워크에 대해 자신감이 없었는데 이번에 아주 재밌게 실습하고 배웠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석 읽기&lt;/li&gt;
  &lt;li&gt;네트워크 공부하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Network" /><category term="Algorithm" /></entry><entry><title type="html">TCP/IP 4계층</title><link href="http://localhost:4000/network/2021/02/01/TCP-IP_4_layer.html" rel="alternate" type="text/html" title="TCP/IP 4계층" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>http://localhost:4000/network/2021/02/01/TCP:IP_4_layer</id><content type="html" xml:base="http://localhost:4000/network/2021/02/01/TCP-IP_4_layer.html">&lt;h2 id=&quot;tcpip-4계층&quot;&gt;TCP/IP 4계층&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;계층모형
&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;계층모형은 컴퓨터들이 정보를 주고받는데 사용하는 프로토콜들을, 각 역할에 맞게 계층으로 나누어 분류한 집합이다.&lt;/p&gt;

  &lt;p&gt;이렇게 역할에 따라 계층을 나눔으로써, 서로 간의 간섭을 최소화하고 사용의 편리성을 높인다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;호환성 보장 (다른 제조사 장비들끼리도 통신 가능)으로 인한 비용 절감&lt;/li&gt;
    &lt;li&gt;문제 발견이 쉬워짐 (어떤 계층에서 문제가 있는지 확인 가능)&lt;/li&gt;
    &lt;li&gt;다른 계층의 전달 과정을 알 필요가 없어 해결해야할 문제가 단순해짐&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;국제표준화기구 IOS(International Organization for Standardization)에서는 상호 이질적인 네트워크간의 연결에서 호환성의 결여를 막기위해 OSI(Open Systems Interconnection) 모형을 개발했다.&lt;/li&gt;
  &lt;li&gt;실제 사용되는 TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형이다
    &lt;ul&gt;
      &lt;li&gt;네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준이 TCP/IP 4계층이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OSI 7계층을 4-5계층으로 분류하여 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4계층-요약&quot;&gt;4계층 요약&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;TCP/IP 4계층&lt;/th&gt;
      &lt;th&gt;역할&lt;/th&gt;
      &lt;th&gt;데이타 단위&lt;/th&gt;
      &lt;th&gt;전송 주소&lt;/th&gt;
      &lt;th&gt;예시&lt;/th&gt;
      &lt;th&gt;장비&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;응용 계층(Application)&lt;/td&gt;
      &lt;td&gt;응용프로그램 간의 데이타 송수신&lt;/td&gt;
      &lt;td&gt;Data/Message&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;전송 계층(Transport)&lt;/td&gt;
      &lt;td&gt;호스트 간의 자료 송수신&lt;/td&gt;
      &lt;td&gt;Segment&lt;/td&gt;
      &lt;td&gt;Port&lt;/td&gt;
      &lt;td&gt;TCP, UDP, RTP, RTCP 등&lt;/td&gt;
      &lt;td&gt;게이트웨이&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;인터넷 계층(Internet)&lt;/td&gt;
      &lt;td&gt;데이타 전송을 위한 논리적 주소 지정 및 경로 지정&lt;/td&gt;
      &lt;td&gt;Packet&lt;/td&gt;
      &lt;td&gt;IP&lt;/td&gt;
      &lt;td&gt;IP, ARP, ICMP, RARP, OSPF&lt;/td&gt;
      &lt;td&gt;라우터&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;네트워크 연결 계층(Network Access)&lt;/td&gt;
      &lt;td&gt;실제 데이타인 프레임을 송수신&lt;/td&gt;
      &lt;td&gt;Frame&lt;/td&gt;
      &lt;td&gt;MAC&lt;/td&gt;
      &lt;td&gt;Ethernet, PPP, Token Ring 등&lt;/td&gt;
      &lt;td&gt;브리지, 스위치&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;l4-응용-계층application-layer&quot;&gt;L4 응용 계층(Application Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: Data/Message&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다&lt;/li&gt;
  &lt;li&gt;응용프로그램(application)들이 데이터를 교환하기 위해 사용되는 프로토콜&lt;/li&gt;
  &lt;li&gt;사용자 응용프로그램 인터페이스를 담당&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;l3-전송-계층transport-layer&quot;&gt;L3 전송 계층(Transport Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: Segment
&lt;strong&gt;전송 주소&lt;/strong&gt;: Port&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신 노드 간의 연결 제어 및 자료 송수신을 담당&lt;/li&gt;
  &lt;li&gt;애플리케이션 계층의 세션과 데이터그램 통신서비스 제공&lt;/li&gt;
  &lt;li&gt;세그먼트 (Segment)단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;실질적인 데이터 전송을 위해 데이타를 일정 크기로 나눈 것. 발신, 수신, 포트주소, 오류검출코드가 붙게된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-1&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;TCP, UDP, RTP, RTCP 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP의 혼잡 방지 알고리즘&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;흐름 제어(Flow Control)&lt;/p&gt;

        &lt;p&gt;송신측과 수신측의 데이터처리 속도 차이를 해결하기 위한 기법이다.&lt;/p&gt;

        &lt;p&gt;수신측이 송신측보다 속도가 빠른것은 아무런 문제가 되지 않지만, &lt;strong&gt;송신측이 수신측보다 속도가 빠르면 문제가 발생한다.&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;수신측에서 수신된 데이터를 처리해서 윗 계층으로 서비스 하는 속도보다 송신측에서 보내는 데이터 속도가 더 빠르다면, 수신측에서 제한된 저장용량(일반적으로 큐)을 초과하여 이후에 도착하는 데이터의 손실을 가져올 수있다.&lt;/p&gt;

        &lt;p&gt;그렇다면 불필요하게 응답과 재전송의 데이터가 다시 송신측과 수신측간에 비번히 이동해야한다.&lt;/p&gt;

        &lt;p&gt;따라서, 이러한 위험을 줄이기 위해 &lt;strong&gt;강제로 송신측의 데이터 전송을 줄인다&lt;/strong&gt;.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Stop and wait 방식&lt;/p&gt;

            &lt;p&gt;매번 전송한 패킷에 대해 확인응답을 받아야만 그 다음 패킷을 전송하는 방법&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;슬라이딩 윈도우 기법&lt;/p&gt;

            &lt;p&gt;수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법이다.&lt;/p&gt;

            &lt;p&gt;이 처럼 슬라이딩 윈도우 기법을 통하여 &lt;strong&gt;송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜&lt;/strong&gt;으로써 흐름제어를 수행한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;혼잡 제어(Congestion control)&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;송신측의 데이터 전달과 네트워크의 처리속도 차이를 해결하기 위한 기법&lt;/strong&gt;이다.&lt;/p&gt;

        &lt;p&gt;송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.&lt;/p&gt;

        &lt;p&gt;하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다.&lt;/p&gt;

        &lt;p&gt;만약, 한 라우터에 데이터가 몰릴 경우, 다시 말해 혼잡할 경우 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.&lt;/p&gt;

        &lt;p&gt;그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.&lt;/p&gt;

        &lt;p&gt;따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이게 된다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Slow start&lt;/p&gt;

            &lt;p&gt;윈도우 크기를 2배로 늘린다.&lt;/p&gt;

            &lt;p&gt;그러다 혼잡현상이 발생하면 창 크기를 1로 떨어뜨린다.&lt;/p&gt;

            &lt;p&gt;그 후 혼잡현상이 발생했던 창 크기의 절반까지는 이전처럼 지수 함수 꼴로(2배로) 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Fast Recovery&lt;/p&gt;

            &lt;p&gt;혼잡한 상태가 되면 창 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/271490475897F87C37&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;출처: &lt;a href=&quot;https://jsonsang2.tistory.com/17&quot;&gt;https://jsonsang2.tistory.com/17&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;l2-인터넷-계층internet-layer&quot;&gt;L2 인터넷 계층(Internet Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: 패킷
&lt;strong&gt;전송 주소&lt;/strong&gt;: IP&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공&lt;/li&gt;
  &lt;li&gt;단말을 구분하기위해 논리적인 주소(Logical Address) IP를 할당
    &lt;ul&gt;
      &lt;li&gt;출발지와 목적지의 논리적 주소가 담겨있는 IP datagram이라는 패킷으로 데이타를 변경&lt;/li&gt;
      &lt;li&gt;데이터 전송을 위한 주소 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라우팅(Routing) 기능을 처리
    &lt;ul&gt;
      &lt;li&gt;경로 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최종 목적지까지 정확하게 연결되도록 연경성 제공&lt;/li&gt;
  &lt;li&gt;패킷단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;세그먼트를 목적지까지 전송하기 위해 시작 주소와 목적지의 논리적 주소를 붙인 단위. 데이타 + IP Header&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-2&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;IP, ARP, ICMP, RARP, OSPF&lt;/p&gt;

&lt;h2 id=&quot;l1-네트워크-연결-계층network-access-layernetwork-interface-layer&quot;&gt;L1 네트워크 연결 계층(Network Access Layer/Network Interface Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: 프레임
&lt;strong&gt;전송 주소&lt;/strong&gt;: MAC&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리적으로 데이타가 네트워크를 통해 어떻게 전송되는지를 정의
    &lt;ul&gt;
      &lt;li&gt;논리주소(IP주소 등)이 아닌 물리주소(예. MAC주소(Media Access Control Address))을 참조해 장비간 전송&lt;/li&gt;
      &lt;li&gt;MAC주소란 컴퓨터의 하드웨워 주소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적으로 에러검출/패킷의 프레임화 담당&lt;/li&gt;
  &lt;li&gt;프레임(Frame)단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;최종적으로 데이타 전송을 하기 전 패킷헤더에 MAC주소와 오류 검출을 위한 부분을 첨부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-3&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;MAC, LAN, 패킷망 등에 사용되는 것
예) Ethernet, PPP, Token Ring 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층&quot;&gt;https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Network" /><category term="TCP/IP" /></entry><entry><title type="html">21년 2월 1일</title><link href="http://localhost:4000/til/2021/02/01/TIL.html" rel="alternate" type="text/html" title="21년 2월 1일" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/02/01/TIL</id><content type="html" xml:base="http://localhost:4000/til/2021/02/01/TIL.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 소켓통신으로 Http Request직접 구현하기를 진행하였다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;URL 클래스를 직접 구현하여, http://www.naver.com:80/test?query=test 와 같은 형식의 url을&lt;/p&gt;

        &lt;p&gt;프로토콜, 도메인 이름, uri, 파라미터등으로 구분하도록 하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;URL클래스 내부적으로 java.net의 InetAddress 클래스를 이용하여 DNS서버에서 IP주소를 알아낸다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;직접 구현한 URL 클래스를 이용하여 http 헤더를 붙여서 소켓통신으로 http request를 보내고 response를 받아온다.(내일 예정)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP/IP 4계층 모델에 대하여 공부 및 포스팅 하였다. (이번 내용은 정보를 서술할 뿐이라 다른 글을 거의 복사했다.)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/network/2021/02/01/TCP-IP_4_layer.html&quot;&gt;TCP/IP 4계층 모델&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 징검다리건너기 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;징검다리건너기&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;각 돌은 건널 수 있는 숫자가 정해져있고(일정 숫자 이상 밟으면 부서진다고 상상), 최대로 점프할 수 있는 거리는 k로 제한된다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;내 풀이:&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;한번에 뛸 수 있는 거리는 k이므로, stones를 전체 순회하며 k 길이만큼의 구간이 사용 가능한 횟수를 구한다.&lt;/p&gt;

                &lt;p&gt;ex) 1~k 구간이 버틸 수 있는 사람 수는 1~k번째 돌에 적힌 숫자 중 최대값이며, 그 다음은 2~k+1번째 구간의 값을 구한다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;이렇게 구한 값중 최소값이 징검다리를 건널 수 있는 최대 인원이다.(k개의 구간이 무너지는 순간 아무도 건널 수 없으므로)&lt;/li&gt;
              &lt;li&gt;결국 구간 max값을 stones길이만큼 구해야 하는데, 효율성 통과를 위해 구간값을 segment tree로 구했다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;다른 사람 풀이:&lt;/p&gt;
            &lt;ol&gt;
              &lt;li&gt;징검다리 건널 수 있는 최대 인원은, 돌에 적힌 숫자 중 최대값과 최소값의 사이이다.&lt;/li&gt;
              &lt;li&gt;binary search로 answer를 바꿔가며, 정답을 찾는다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크는 대학교때도 꺼려했던 과목이라 기본이 많이 부족하다.&lt;/li&gt;
  &lt;li&gt;기본이 부족한데도 조급함을 느끼며 빨리빨리 하려고 했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다시 일상으로 복귀하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;조바심을 느껴 쓱 훑고 빨리 구현하려고 하니, 아무것도 하지 못한 느낌이다.&lt;/li&gt;
  &lt;li&gt;기본이 부족하면 차근차근 공부해야겠다. 시간은 많다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;네트워크 공부하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Network" /><category term="Algorithm" /></entry><entry><title type="html">21년 1월 30일</title><link href="http://localhost:4000/til/2021/01/30/TIL25.html" rel="alternate" type="text/html" title="21년 1월 30일" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/30/TIL25</id><content type="html" xml:base="http://localhost:4000/til/2021/01/30/TIL25.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 셔틀버스 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;셔틀버스&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;탑승을 위해 고려하는 timetable의 최대 개수가 2000이기 때문에, 구현자체가 중요하다고 생각했다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;간단한 구현이었다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;timetable을 시간순서로 정렬한다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;주어진 간격대로 셔틀버스를 출발시키고, 탈 수 있는 승객을 태운다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;마지막 셔틀버스를 출발시킬 때&lt;/p&gt;

                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;p&gt;정원이 꽉차지 않았다면 마지막 셔틀버스출발시간에 줄을 서야한다.&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;정원이 꽉찼다면 마지막 승객보다 1분 빨리 줄을 서야한다.&lt;/p&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;계획한 걸 제대로 못하고 있다. 알고리즘만 한문제 겨우 풀었다.&lt;/li&gt;
  &lt;li&gt;개인 멘탈 문제이다. 안좋은 일이 많은 한 주였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;요즘 집중이 흐트러진다.&lt;/li&gt;
  &lt;li&gt;개발 자체는 재밌지만, 블로그 글을 쓰는 것에 대한 부담?때문에 공부를 회피하는것 같다.&lt;/li&gt;
  &lt;li&gt;글을 잘 쓰려고 부담을 갖지말아야겠다 ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;쉬기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Load Data (bulk insert) 시도 secure_file_priv 문제 뜰 때</title><link href="http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err.html" rel="alternate" type="text/html" title="Load Data (bulk insert) 시도 secure_file_priv 문제 뜰 때" /><published>2021-01-29T00:00:00+09:00</published><updated>2021-01-29T00:00:00+09:00</updated><id>http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err</id><content type="html" xml:base="http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err.html">&lt;h2 id=&quot;mysql-에서-bulk-insert-명령을-실행할-때-secure_file_priv-에러-발생&quot;&gt;Mysql 에서 bulk insert 명령을 실행할 때, secure_file_priv 에러 발생&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;쉘스크립트에서 아래와 같이 특정 파일을 bulk insert시도 하였고 secure_file_priv에러 발생하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test.sh&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
  
mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;패스워드 db명 &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
  
LOAD DATA INFILE 'test.txt'
INTO TABLE user_log
FIELDS TERMINATED BY ',';
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR 1290 (HY000) at line 2: The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mysql에 접속하여 변수 상태를 확인한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SELECT @@GLOBAL.secure_file_priv;
+---------------------------+
| @@GLOBAL.secure_file_priv |
+---------------------------+
| /var/lib/mysql-files/     |
+---------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 secure_file_priv에 설정된 경로에 파일이 위치해야만 bulk insert가 가능하다고 한다.&lt;/p&gt;

&lt;p&gt;다만, mysql 설정 파일에 아래 내용을 추가한 후 mysql을 재시작하면 아무 위치에서나 bulk insert가 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[mysqld]
secure-file-priv=&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Mysql" /></entry><entry><title type="html">21년 1월 28일</title><link href="http://localhost:4000/til/2021/01/28/TIL24.html" rel="alternate" type="text/html" title="21년 1월 28일" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/28/TIL24</id><content type="html" xml:base="http://localhost:4000/til/2021/01/28/TIL24.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 docker로 mysql을 실행하고 locale 설정하는 과정을 진행했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;도커허브의 mysql:5.7 이미지를 이용하여 실행했다.&lt;/li&gt;
      &lt;li&gt;해당 이미지는 debian linux를 토대로 mysql이 설치되어 있었다.&lt;/li&gt;
      &lt;li&gt;debian에서 locale설정하는 법을 알게 되었다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;쉘 스크립트를 이용해 file을 작성하고 file을 bulk insert하여 100만개의 랜덤데이터를 생성했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/docker/2021/01/28/Docker_mysql_image_run_config.html&quot;&gt;환경설정한 기록&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;전날 늦게 잔 후유증으로 집중이 잘안되서 일찍 자버렸다.&lt;/li&gt;
  &lt;li&gt;코드스쿼드 미션 이외에 개인공부를 하지 못했다(알고리즘, 자바의정석 읽기 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;회사에서 종종 사용하던 docker를 이용한 미션이 나와서 반가웠다.&lt;/li&gt;
  &lt;li&gt;자주 사용하지 못해서 docker docs를 확인하며 명령을 실행했고 익숙해져서 기분이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Docker" /><category term="Algorithm" /></entry><entry><title type="html">Docker mysql 이미지 실행 및 한글설정</title><link href="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html" rel="alternate" type="text/html" title="Docker mysql 이미지 실행 및 한글설정" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config</id><content type="html" xml:base="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html">&lt;h3 id=&quot;docker-docs를-참고하여-진행했습니다&quot;&gt;Docker Docs를 참고하여 진행했습니다.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;Docker Docs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql-이미지를-컨테이너로-실행하고-설정한-기록&quot;&gt;mysql 이미지를 컨테이너로 실행하고 설정한 기록&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;docker hub 에서 mysql image pull 받기&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;image를 container로 실행하기(-d는 background로 실행, -e는 환경변수 설정한다는 뜻)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ROOT_PWD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;비밀번호 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너에게 exec명령어로 bash 실행하기 (-i는 Keep STDIN open even if not attached라는 뜻, -t 는 psedo TTY를 할당한다)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docer &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; mysql /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;locale 설정하기 (Debian Linux 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update
apt upgrade
apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; locales locales-all
dpkg-reconfigure locales &lt;span class=&quot;c&quot;&gt;#여기서 실행되는 프로그램에서 ko_KR.UTF-8을 선택&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;4-1) 현재 컨테이너를 이미지로 만든 후 LC_ALL 환경변수를 ko_KR.UTF-8로 변경하여 재실행한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker commit mysql isaac/mysql
docker container &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;mysql
docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;LC_ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ko_KR.UTF-8 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; isaac/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql -uroot -p비밀번호 명령어를 통해 mysql 접속한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uroot -p루트비번
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;status 명령어로 현재 설정 확인하면 characterset이 latin1로 되어있는 걸 확인할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; status
--------------
mysql  Ver 14.14 Distrib 5.7.33, for Linux (x86_64) using  EditLine wrapper
   
Connection id:		3
Current database:	
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.7.33 MySQL Community Server (GPL)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	latin1
Db     characterset:	latin1
Client characterset:	latin1
Conn.  characterset:	latin1
UNIX socket:		/var/run/mysqld/mysqld.sock
Uptime:			49 min 29 sec
   
Threads: 1  Questions: 7  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.002
--------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/mysql/mysql.conf.d/mysqld.cnf 파일을 수정해준다. (도커허브 mysql:5.7 이미지 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//아래 내용을 파일에 추가해준다.
[client]
default-character-set=utf8
   
[mysql]
default-character-set=utf8
   
[mysqld]
collation-server = utf8_unicode_ci
init-connect='SET NAMES utf8'
character-set-server = utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docer container 명령어로 restart시켜준다&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker container restart mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Docker" /></entry><entry><title type="html">21년 1월 27일</title><link href="http://localhost:4000/til/2021/01/27/TIL23.html" rel="alternate" type="text/html" title="21년 1월 27일" /><published>2021-01-27T00:00:00+09:00</published><updated>2021-01-27T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/27/TIL23</id><content type="html" xml:base="http://localhost:4000/til/2021/01/27/TIL23.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 비동기 프로그래밍 미션을 하루종일 했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;미션에서 주어진 역할을 클래스로 만들고 객체간의 메세지를 보내(메소드 실행) 이벤트를 발생하게 했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;객체 각자가 비동기적으로 일을 수행해, 주문을 받은 커피를 만들고 커피가 완료됐다고 출력하는 미션이었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만든 클래스는 다음과 같다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;주문을 받는 Cashier Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문 목록을 갖고있는 OrderList Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;OrderList를 보고 일을 할당해주는 Manager Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피를 만드는 Barista Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;완료된 목록을 출력해주는 DashBoard Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류인 CoffeeType Enum&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류와 주문한 고객정보를 갖고있는 Coffee Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문한 고객정보와 Coffee를 모두 담고 있는 Order Class&lt;/p&gt;

            &lt;p&gt;(고객1이 아메리카노2잔,카페라떼3잔을 시켰다면 커피1잔은 Coffee Class에 해당하고, 전체 주문 한건은 Order Class에 해당)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture에서 제공하는 runAsync나 supplyAsync를 사용하면 Executors로 직접 쓰레드풀을 생성할 필요가 없이,&lt;/p&gt;

        &lt;p&gt;ForkJoinPool에서 제공하는 쓰레드 풀에 Task를 할당할 수 있다. (매우 편리하다!)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture를 사용하면 콜백지옥없이 thenApplyAsync와 같은 메소드를 통해, promise패턴으로 구현이 가능하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;모든 주문이 완료된 상태에서 3초간 input이 들어오지 않으면 종료시킨다는 조건이 있었는데, io 블락중인 상태를 어떻게 종료해야할지 몰라서 정말 힘들었다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;io입력 받는 부분을 CompletFuture를 통해 non-block 상태로 실행시킨다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;future.getNow(null) 메소드를 통해 (task가 완료되면 리턴값을, 아직 진행중이면 null을 반환한다는 의미)&lt;/p&gt;

            &lt;p&gt;io로 input이 들어왔는지 판단한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;io로 input이 들어오지 않은 상태에서 모든 주문이 끝났고, 주문이 끝난지 3초 이상 지났으면 함수를 return해준다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;데몬 쓰레드에서 돌고있는 Scanner.nextLine()이 종료되지 않은 상태에서 메인 쓰레드가 종료되기 때문에, 프로세스가 종료된다.&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showMenu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//메뉴 목록 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showHowToOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문하는 방법 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문받기 시작했기 때문에, 주문이 완료된적 없음&lt;/span&gt;
       
        &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;supplyAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//listen값이 null이 아닌동안 계속 확인&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{};&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문완료, 3초 지났으면 종료&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;모든 메뉴가 완성되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;translateOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;올바른 형식을 입력해주세요.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;orderList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;미션이 생각보다 어려워서, 알고리즘 공부와 자바의정석 읽기를 못했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;생각보다 어려웠는데 새벽 3시까지 코딩해서 결국 다 만들었다 ㅎㅎ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;힘든 일이 있어서 멘붕이 왔었는데, 다시 회복하고 있다.&lt;/li&gt;
  &lt;li&gt;깨졌던 공부 루틴을 회복하기 시작해서 좋다.&lt;/li&gt;
  &lt;li&gt;CompleteFuture를 사용하니까 너무 편리하다. (내부 작동원리 등은 계속 써가면서 공부해야 할 것 같다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 26일</title><link href="http://localhost:4000/til/2021/01/26/TIL22.html" rel="alternate" type="text/html" title="21년 1월 26일" /><published>2021-01-26T00:00:00+09:00</published><updated>2021-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/26/TIL22</id><content type="html" xml:base="http://localhost:4000/til/2021/01/26/TIL22.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 단어변환 문제를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;단어변환:
        &lt;ol&gt;
          &lt;li&gt;간단한 BFS문제이다.&lt;/li&gt;
          &lt;li&gt;문제에서 주어진 규칙만 준수하여, visit체크와 함께 변환한 단어를 queue에 넣어준다.&lt;/li&gt;
          &lt;li&gt;queue에서 꺼낸 값이 target과 일치할 경우 변환한 개수를 반환하면 된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 처음으로 TIL도 쓰지 않고, 아무것도 하지 못했다.&lt;/li&gt;
  &lt;li&gt;오늘도 코드스쿼드 미션은 읽어보지도 못하고 울면서 알고리즘 한문제만 겨우 푼거같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 오늘 개인사정으로 인해 정말 오르락내리락 멘탈이 무너졌던 이틀이었다.&lt;/li&gt;
  &lt;li&gt;무슨일이 생겨도 꾸준히 하던 것을 놓으면 안되는데, 애초에 멘탈을 강하게 지켜야하는데 이번 일은 그게 좀 힘들었다.&lt;/li&gt;
  &lt;li&gt;내일부터 다시 제대로 열심히 꾸준히 해보려고한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking</title><link href="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html" rel="alternate" type="text/html" title="Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking" /><published>2021-01-25T00:00:00+09:00</published><updated>2021-01-25T00:00:00+09:00</updated><id>http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking</id><content type="html" xml:base="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html">&lt;h2 id=&quot;synchronous--asynchronous&quot;&gt;Synchronous / Asynchronous&lt;/h2&gt;

&lt;p&gt;Synchronous의 어원부터 살펴보면, Sync (함께) + Chrono(시간) 이 합쳐진 단어이다.&lt;/p&gt;

&lt;p&gt;즉, Synchronous란 ‘함께 시간을 맞춰 행동한다’고 해석할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, B라는 function을 사용하는 A라는 function이 있다고 해보자&lt;/p&gt;

&lt;p&gt;여기서 A는 호출한 자라고 할 수 있고, B는 호출받은 자라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;synchronous&quot;&gt;Synchronous&lt;/h3&gt;

&lt;p&gt;A는 B를 호출하게 되고, B가 종료되는 시점에 A가 그 다음 동작을 수행한다면 Synchronous라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하면 Synchronous인 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 시간을 맞춰 행동하면 코드의 작성 순서대로 실행된다는 것을 보장할 수 있게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 시작되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 끝났습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B입니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바는 기본적으로 Blocking / Synchronous한 언어이기 때문에, A() 메소드를 실행한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A가 시작되었습니다.&lt;/li&gt;
  &lt;li&gt;B입니다.&lt;/li&gt;
  &lt;li&gt;A가 끝났습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;순서로 출력이 될 것이다.&lt;/p&gt;

&lt;p&gt;Synchronous하기 때문에, B의 호출이 끝나는 시간과 A가 시작되는 시간이 일치하기 때문이다.&lt;/p&gt;

&lt;p&gt;다시 말하면, B의 호출이 끝난 후(“B입니다.” 출력) A가 다시 시작하여 (“A가 끝났습니다.”)를 출력하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;asynchrnous&quot;&gt;Asynchrnous&lt;/h3&gt;

&lt;p&gt;Asynchronous는 Synchronous에 반대를 뜻하는 접두사 A가 붙은 형태이다.&lt;/p&gt;

&lt;p&gt;즉, 시간을 맞추지 않는다고 생각하면 될 것이다.&lt;/p&gt;

&lt;p&gt;A가 B를 호출한 뒤, B의 종료여부를 신경쓰지 않고 다시 A가 작업을 재개하는 것을 생각하면된다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하지 않는 것이다.&lt;/p&gt;

&lt;p&gt;위의 예가 Asynchronous하게 동작한다면,&lt;/p&gt;

&lt;p&gt;A는 B를 호출한 후 B의 종료 시점을 기다리지 않고, “A가 끝났습니다.”를 출력하려고 할 것이다.&lt;/p&gt;

&lt;p&gt;따라서, “B입니다.”가 먼저 출력될지 “A가 끝났습니다.”가 먼저 출력될지 알 수 없게 된다.&lt;/p&gt;

&lt;p&gt;코드의 작성 순서대로 실행되는 것이 보장되지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;blocking--non-blocking&quot;&gt;Blocking / Non-Blocking&lt;/h2&gt;

&lt;p&gt;Blocking과 Non-Blocking을 설명하기 위해서 제어권이라는 용어가 많이 사용된다.&lt;/p&gt;

&lt;p&gt;간단하게, 제어권이란 스스로 동작할 수 있는 권리라고 이해하면 된다.&lt;/p&gt;

&lt;p&gt;A라는 함수에 제어권이 있다면 A는 현재 동작할 수 있는 상태인 것이다.&lt;/p&gt;

&lt;p&gt;Blocking / Non-Blocking은 이런 제어권의 반환이 언제 되느냐에 대한 관점이다.&lt;/p&gt;

&lt;h3 id=&quot;blocking&quot;&gt;Blocking&lt;/h3&gt;

&lt;p&gt;Blocking은 호출된 함수가 종료될 때까지 호출한 자에게 제어권을 넘겨주지 않는 것이다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;non-blocking&quot;&gt;Non-Blocking&lt;/h3&gt;

&lt;p&gt;Non-Blocking에서 호출된 함수는 제어권을 바로 호출한 함수에게 넘겨준다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하지 않는다.&lt;/p&gt;

&lt;p&gt;Non-Blocking 함수를 호출한다면, 호출자에게 제어권을 바로 반환하기 때문에,&lt;/p&gt;

&lt;p&gt;호출자는 자신의 동작을 진행할 수 있고, 호출된 함수도 자신의 동작을 진행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참고하기 매우 좋은 글&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&quot;&gt;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Synchronous" /><category term="Asynchronous" /><category term="Blocking" /><category term="Non-Bolocking" /></entry></feed>