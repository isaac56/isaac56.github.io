<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-22T00:02:31+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">Process와 Thread</title><link href="http://localhost:4000/os/2021/01/21/Process_vs_Thread.html" rel="alternate" type="text/html" title="Process와 Thread" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>http://localhost:4000/os/2021/01/21/Process_vs_Thread</id><content type="html" xml:base="http://localhost:4000/os/2021/01/21/Process_vs_Thread.html">&lt;h2 id=&quot;process-란&quot;&gt;Process 란&lt;/h2&gt;

&lt;p&gt;일반적으로 Process는 프로그램을 실행시킨 상태라고도 하고, 실행중인 프로그램이라고도 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 실행중이라는 상태는 구체적으로 어떤 모양일까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;프로그램은 디스크에 저장된 정적 데이터와 코드의 모임일 뿐이다.&lt;/p&gt;

&lt;p&gt;프로그램이 프로세스로 실행되는 과정을 간단하게(?) 설명하면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;운영체제는 프로그램의 코드와 정적 데이터를 프로세스의 메모리 공간(Code와 Data 영역)에 적재한다.&lt;/li&gt;
  &lt;li&gt;main함수를 찾아 CPU의 PC(Program Counter) 레지스터에 실행할 코드의 메모리 주소를 저장한다.&lt;/li&gt;
  &lt;li&gt;프로그램 실행 시 입력했던 Argument와 함께 Stack 영역을 구성한다.&lt;/li&gt;
  &lt;li&gt;프로세스가 사용할 Heap영역의 메모리를 할당한다.(Heap 영역은 동적 할당을 위해 사용된다.)&lt;/li&gt;
  &lt;li&gt;PC 레지스터가 가리키는 명령를 실행하기 위해, 데이터를 메모리로부터 읽어 레지스터에 저장한다.&lt;/li&gt;
  &lt;li&gt;레지스터에 저장한 값을 읽어 ALU가 명령에 따라 계산하고, 이 값을 다시 결과값 레지스터에 저장한다.&lt;/li&gt;
  &lt;li&gt;레지스터에 저장된 결과값을 다시 메모리에 저장한다.&lt;/li&gt;
  &lt;li&gt;PC 레지스터의 값을 증가시켜 다음 명령을 실행할 준비를 한다.&lt;/li&gt;
  &lt;li&gt;(5)~(8)이 반복되며 프로세스가 진행된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런식으로 프로세스는 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, Process란 디스크에 저장되어 있던 코드뭉치를 메모리에 적재하여 실행 가능하게 한 상태라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;context-switch&quot;&gt;Context Switch&lt;/h2&gt;

&lt;p&gt;일반적으로 OS는 마치 CPU 여러대가 있는 것처럼 착각할 수 있도록, 시분할 기법을 사용하여 프로세스들을 실행시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 프로세스가 3개 있다고 했을 때, 1번을 아주 조~금 실행한 후, 2번을 아주 조~금 실행한 후,&lt;/p&gt;

&lt;p&gt;3번을 아주 조~금 실행하는 방식을 통해 모든 프로세스가 동시에 진행되는 것처럼 느끼게 해준다.&lt;/p&gt;

&lt;p&gt;(어떤 순서로 돌아가며 프로세스를 실행시킬 지는 스케줄러 정책에 따라 다르다.)&lt;/p&gt;

&lt;p&gt;마치 CPU가 여러대 있는 것처럼 느끼게 해주는 것인데, 이렇게 하기 위해선 Context Switch가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Context란 아주 간단하다. Process가 실행되던 그 상황을 의미한다.&lt;/p&gt;

&lt;p&gt;1번 프로세스를 그 상황 그대로 멈추게 한 후, 마찬가지로 멈춰 있던 2번 프로세스를 실행시켜줘야 하고,&lt;/p&gt;

&lt;p&gt;다시 1번 프로세스를 실행할 시간이 되면 멈췄던 그 상황 그대로 되살려서 실행해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 그 ‘상황’(Context)는 어떻게 저장할까?&lt;/p&gt;

&lt;p&gt;위에서 설명한 Process를 통해 유추해볼 수 있는데,&lt;/p&gt;

&lt;p&gt;프로세스가 사용하던 Memory 주소와 레지스터값들을 저장하면 된다!&lt;/p&gt;

&lt;p&gt;(Memory 주소를 저장하는 이유는 메모리 가상화와 관련된 내용인데 지금은 다루지 않겠다.)&lt;/p&gt;

&lt;p&gt;(이 외에도 pid, process state, open files 등 저장할 값들이 있지만 생략하겠다. )&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그 상황에 사용하던 레지스터 값(PC를 포함한)들을 다시 CPU의 레지스터에 올리게 되면,&lt;/p&gt;

&lt;p&gt;다시 PC에 저장된 메모리 주소를 읽어 명령을 실행함으로써, 정지되었던 그 상황에서 실행하는 것이 가능해진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이런 context를 저장하는 구조체를 PCB(Process Control Block) 이라고 하는데,&lt;/p&gt;

&lt;p&gt;실행중인 Process의 PCB를 메모리에 저장한 후, 다음 실행할 Process의 PCB를&lt;/p&gt;

&lt;p&gt;메모리에서 읽어(CPU 레지스터에 올려) 실행하는 것을 Context Switch라고 한다.&lt;/p&gt;

&lt;p&gt;(User mode, kernel mode 간의 switch 등 많은 과정이 생략되었으니, 자세히 알고 싶으면 관련 내용을 찾아보기 바란다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thread-란&quot;&gt;Thread 란&lt;/h2&gt;

&lt;p&gt;Thread는 Process에 종속된 개념으로 실제로 작업을 수행하는 주체라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;위 설명에서 Process가 실행될 때 main함수를 찾아 PC에 저장해주고 Stack 프레임을 구성해준다고 했는데,&lt;/p&gt;

&lt;p&gt;이것은 프로세스의 시작이라고 할 수도 있지만, 메인 쓰레드의 시작이라고 할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쓰레드는 각각 레지스터 셋(PC를 포함한)과 Stack프레임을 갖고 있어서,&lt;/p&gt;

&lt;p&gt;한 프로세스이지만 각각의 쓰레드가 독립적으로 명령을 수행하는 것처럼 보이게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;어? 위에서 설명한 Context Switch를 보면, 레지스터 셋은 Context고 이걸 각각 갖고 있으면 Process가 아닌가?&lt;/p&gt;

&lt;p&gt;라고 생각할 수 있지만, 가장 큰 차이점은 같은 Process의 쓰레드는 메모리 공간을 공유한다는 것이다.&lt;/p&gt;

&lt;p&gt;쓰레드는 레지스터셋과 Stack프레임을 각각 갖고 있지만, 프로세스의 Code, Data, Heap 메모리 공간을 공유한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;따라서 쓰레드간의 Context switch에서는 쓰레드가 사용할 메모리 주소값을 교체할 필요가 없고,&lt;/p&gt;

&lt;p&gt;레지스터 값과 Stack Pointer만 교체하면 되므로 Context Switch의 오버헤드가 프로세스보다 훨씬 적다.&lt;/p&gt;

&lt;p&gt;뿐만 아니라, Data나 Heap 영역을 공유하므로 쓰레드 간의 데이터 공유도 가능하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process끼리는 Memory Protection 정책에 의해 같은 메모리로 접근이 불가능하다.&lt;/p&gt;

  &lt;p&gt;Process끼리는 시스템에서 제공하는 IPC(Inter Process Communication)으로만 통신 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;요약-process-vs-thread&quot;&gt;요약 (Process vs Thread)&lt;/h1&gt;

&lt;p&gt;프로세스: 운영체제로부터 메모리를 할당받아 실행할 수 있게된 작업의 단위 (메모리에 올라간 프로그램)&lt;/p&gt;

&lt;p&gt;스레드: 프로세스가 할당받은 메모리를 이용하는 실행 흐름의 단위 (프로그램을 실행하는 독립적인 실행 흐름)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Thread의 장점:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쓰레드 간의 Context Switching이 프로세스 간의 Context Switching보다 빠르다.&lt;/li&gt;
  &lt;li&gt;Stack을 제외한 메모리 자원을 공유하고 있어서, 쓰레드 간의 통신이 프로세스 간의 통신보다 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thread의 단점:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Process의 자원을 공유하기 때문에, 쓰레드 중 하나에 문제만 생겨도 Process가 종료되고, 따라서 전체 쓰레드도 종료된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stack을 제외한 메모리 자원을 공유하고 있어서, 프로그램 설계와 디버깅이 어렵다.&lt;/p&gt;

    &lt;p&gt;(동시에 같은 변수에 접근할 수 있기 때문에, 이상 동작을 고려한 설계가 필요하다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="OS" /><category term="Process" /><category term="Thread" /></entry><entry><title type="html">21년 1월 21일</title><link href="http://localhost:4000/til/2021/01/21/TIL18.html" rel="alternate" type="text/html" title="21년 1월 21일" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/21/TIL18</id><content type="html" xml:base="http://localhost:4000/til/2021/01/21/TIL18.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스와 스레드의 차이점에 대해 공부하였다.&lt;/li&gt;
  &lt;li&gt;프로세스는 메모리에 적재하여 실행가능한 상태의 작업 단위이다.
    &lt;ul&gt;
      &lt;li&gt;스레드는 프로세스에 할당된 메모리 자원을 이용하여 실행되는 프로세스 내의 독립 실행 흐름이다.&lt;/li&gt;
      &lt;li&gt;스레드 간의 Context Switch는 레지스터 값과 Stack Pointer만 변경하면 되기 때문에 Process의 Context switch보다 빠르다.&lt;/li&gt;
      &lt;li&gt;스레드는 Stack영역 이외의 공간을 공유하기 때문에, 스레드 간의 통신이 쉽다.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/os/2021/01/21/Process_vs_Thread.html&quot;&gt;Process vs Thread&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OperatingSystem Three Easy Pieces 책을 80 page까지 읽었다.
    &lt;ul&gt;
      &lt;li&gt;운영체제의 주요 컨셉인 CPU 가상화, 메모리 가상화, 동시 실행, 영속성을 배웠다.&lt;/li&gt;
      &lt;li&gt;프로세스가 실행되는 과정을 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 모드로의 전환과 프로세스 간의 컨텍스트 스위치 과정에 대해 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 권한과 이에 따른 시스템 콜, 트랩 핸들러에 대해 배웠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 불량 사용자를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;불량 사용자:
        &lt;ul&gt;
          &lt;li&gt;처음에 쉽게 접근했다가 복잡하다는 것을 깨달았다.&lt;/li&gt;
          &lt;li&gt;DFS로 풀었는데, HashSet을 남발하여 다소 찜찜하다.&lt;/li&gt;
          &lt;li&gt;DFS안에 현재까지의 불량 사용자 목록을 HashSet으로 담는다.&lt;/li&gt;
          &lt;li&gt;모든 밴 리스트를 참고하여 HashSet을 완성했으면 HashSet의 HashSet에 추가하여 중복을 제거한다.&lt;/li&gt;
          &lt;li&gt;HashSet의 HashSet의 size()가 정답의 개수가 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;OS를 오랜만에 복습하고, 글로 정리하여 포스팅하였다.&lt;/li&gt;
  &lt;li&gt;레벨 3 카카오 문제를 한번에 풀었다 (80분 걸림)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;오랜만에 OS를 복습했는데, 생각보다 까먹은게 많아서 아쉬웠다.(3학년때 정말 열심히 했는데 ㅠㅠ)&lt;/li&gt;
  &lt;li&gt;그래도 빠르게 읽고 다시 기억할 수 있어서 공부하길 잘했다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;카카오 문제 풀긴 했는데 HashSet의 HashSet을 쓴게 찜찜하여 다른 사람은 어떻게 풀었는지 참고해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 20일</title><link href="http://localhost:4000/til/2021/01/20/TIL17.html" rel="alternate" type="text/html" title="21년 1월 20일" /><published>2021-01-20T00:00:00+09:00</published><updated>2021-01-20T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/20/TIL17</id><content type="html" xml:base="http://localhost:4000/til/2021/01/20/TIL17.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스의 크레인 인형뽑기 게임, 이상한 문자 만들기, 구명보트, 섬 연결하기를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;크레인 인형뽑기 게임:
        &lt;ul&gt;
          &lt;li&gt;주어진 규칙에 맞게 구현만 하면 되는 레벨1짜리 문제였다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이상한 문자 만들기:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;마찬가지로 주어진 구현만 하면 되는 쉬운 문제였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;하지만 문제를 자의적으로 해석해 틀리고 말았다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;공백으로 구분된 문자들을 기준으로 짝수번째는 대문자 홀수번째는 소문자로 바꾸는 문제였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;쉬운 문제였는데 틀리고 말았다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;나는 자의적으로 해석하여, 공백을 기준으로 단어를 split한 후 대문자,소문자를 적용하고나서 다시 공백으로 합쳤다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;문제에서 각 문자들이 공백 하나로만 구분된다거나 맨마지막 단어 뒤에 공백이 없다는 조건이 없었다.&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;문제를 제대로 읽고, 문제에서 제약조건으로 알려주지 않은 모든 경우의 수를 생각하며 풀어야 한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구명보트:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;풀었던 문제인데도 효율성에서 시간초과가 나서 결국 답을 보고 풀었다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;무게순으로 정렬 후 순회하며 풀어나가는 문제이다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;순회하는 기준을 어디로 두냐의 문제였다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;무게가 작은 사람을 기준으로 순회한다면, 같이 보트를 태울 사람을 최대무게부터&lt;/p&gt;

                &lt;p&gt;현재 무게 더해도 한계를 안넘는 사람을 찾을 때까지 줄여나가며 찾아야 한고 못 찾으면 현재 무게만 태운다.&lt;/p&gt;

                &lt;p&gt;(모든 사람의 무게가 limit인 경우 항상 이중포문을 돌게 된다.)&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;무게를 큰 사람을 기준으로 순회한다면, 같이 보트를 태울 사람을 찾을 때, 최소무게+현재무게가 한계를 안넘으면 태우고,&lt;/p&gt;

                &lt;p&gt;한계를 넘으면 현재 무게만 보트에 태우면 된다.(무게가 큰 사람부터 순회하기 때문)&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;시간초과가 나는 것을 보고, 도저히 해결못하겠다고 생각했는데 기준만 다르게 생각하면 되는 문제였다 ㅠㅠ&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;섬 연결하기:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;그냥 크루스칼 알고리즘으로 풀라고 던져준 문제 같았다.&lt;/li&gt;
          &lt;li&gt;union-find 기법과 kruskal 알고리즘으로 간단하게 풀 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한달의 중간을 안쉬고 달렸다는 핑계로 쉬는 시간이 많았다.&lt;/li&gt;
  &lt;li&gt;책을 아예 안보고 있다. 조금이라도 전진하는 것과 멈추는 것은 다른 문제인데..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;그래도 오늘 하기로 계획한 알고리즘 문제는 모두 풀었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;완독하기로 한 책을 조금씩이라도 읽어야 발전하는데 아예 진행을 안하고 있다.&lt;/li&gt;
  &lt;li&gt;진짜 고질적인 문제인데, 계획한 시간을 넘으면 잠시 멈추고 하기로 한 일을 진행해야 한다.&lt;/li&gt;
  &lt;li&gt;걱정이 많이 된다. 쉴 땐 쉬고 할 땐 하는 연습이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 19일</title><link href="http://localhost:4000/til/2021/01/19/TIL16.html" rel="alternate" type="text/html" title="21년 1월 19일" /><published>2021-01-19T00:00:00+09:00</published><updated>2021-01-19T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/19/TIL16</id><content type="html" xml:base="http://localhost:4000/til/2021/01/19/TIL16.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바8부터 함수형 프로그래밍을 지원하기 위해 나온 함수형 인터페이스에 대해 공부하였다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;자바의 정석 Chapter 14를 참고하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;클로저는 단순히 익명함수가 아니라, 익명함수가 선언될 당시의 외부스코프(lexical Envirionment)를 포함한 것이다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;함수라고 할 수도 있고, 자료구조라고 할 수도 있다.&lt;/li&gt;
          &lt;li&gt;자바에서 클로저에 담긴 외부스코프의 변수는 final취급이 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사실 람다식은 익명 클래스이자 익명 객체의 생성자이고,&lt;/p&gt;

        &lt;p&gt;이와 일치하는 인터페이스에 대입해줘야 컴파일러가 알아서 해당 인터페이스로 형변환을 해준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Runnable, Supplier, Function, UnaryOperator 등 자바에서는 함수형 프로그래밍을 지원하기 위해&lt;/p&gt;

        &lt;p&gt;다양한 Functional Interface를 준비해두었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;준비된 Functional Interface외에 필요한 게 생긴다면 직접 구현해서 사용해도 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;특정 메소드를 참조하기만 하는 람다식은 메소드 참조 식으로 바꿀 수 있다.&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.function.Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; method&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     
&lt;span class=&quot;c1&quot;&gt;//두 식 모두 동일&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;con1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;con2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Test:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스의 체육복, 조이스틱, 큰수만들기를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;체육복:
        &lt;ul&gt;
          &lt;li&gt;앞에서부터 순회하며 당장 빌려줄 체육복이 있으면 빌려줄 사람이 있는지 확인하고 왼쪽, 오른쪽 순으로 빌려주면 된다.&lt;/li&gt;
          &lt;li&gt;간단한 greedy 문제이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;조이스틱:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;위 아래 버튼으로 인한 최소 입력개수는 정해져 있어서 어려울게 없다.&lt;/li&gt;
          &lt;li&gt;왼쪽 오른쪽 버튼으로 인한 최소 입력개수를 구하기 위해서는 이동하는 범위를 그림적으로 생각해야 한다.&lt;/li&gt;
          &lt;li&gt;0인덱스를 제외하고, 순회하며 ‘A’가 아닌 P1과 그 다음 ‘A’가 아닌 P2를 통해 수평 버튼이 눌릴 수 있는 경우의 수를 생각한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;큰수만들기:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;이건 정말 어려워서 결국 못 풀고 답을 봤다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;빼야하는 k개와 남아있어야 하는 n-k개를 나눈 후,&lt;/p&gt;

            &lt;p&gt;k개의 뒤쪽 기준으로  n-k개의 앞쪽부터 하나하나 비교하며 swap 해줘야 기존의 숫자 순서를 오염시키지 않고 k개를 빼는게 가능하다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;글로 설명이 힘들어서 코드를 봐야 이해할 수 있을 것이다.&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]){&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
       
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;copyOfRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;charArr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘 문제를 또 오래 잡고있다보니 시간조절이 안되었다.&lt;/li&gt;
  &lt;li&gt;이건 고질적인 문제라서 할말이없다. ㅠㅠ&lt;/li&gt;
  &lt;li&gt;시간 조절하는 연습을 꼭 할것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;너무 피곤해서 오늘은 쉴까 생각했었는데, 그래도 다시 정상 궤도로 돌아왔다.&lt;/li&gt;
  &lt;li&gt;꾸준히 하는게 중요한데 꾸준히 하고 있어서 다행이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;함수형 프로그래밍은 함수를 객체처럼 사용할 수 있어야 하기 때문에, Functional Interface를 사용해야 한다고 생각한다.&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍은 지금 내 수준으로 완벽히 이해하기 힘들고, 그런 식으로 구현하기도 힘들것 같다.&lt;/li&gt;
  &lt;li&gt;그냥 그런 패러다임이 있구나 자바에선 이런걸 제공하는 구나 정도만 알고 넘어가야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Functional Interface" /><category term="Algorithm" /></entry><entry><title type="html">21년 1월 18일</title><link href="http://localhost:4000/til/2021/01/18/TIL15.html" rel="alternate" type="text/html" title="21년 1월 18일" /><published>2021-01-18T00:00:00+09:00</published><updated>2021-01-18T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/18/TIL15</id><content type="html" xml:base="http://localhost:4000/til/2021/01/18/TIL15.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수형 프로그래밍이 무엇인지 학습하고 정리하였다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;프로그램을 함수의 조합으로 바라보는 패러다임이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;여기서 함수는 불변성과 순수함수라는 특징이 있어, 어떤 상태인지에 따른 side effect가 발생하지 않는다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;비동기 프로그래밍에 있어서도 side effect가 발생하지 않는다.&lt;/p&gt;

        &lt;p&gt;(인풋에 의해 결정되는 함수들의 조합이기 때문에 thread간에 공유되는 변수가 없다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;자바에서 함수형 프로그래밍을 위해 인터페이스 생성자로 람다식을 사용하고, 메소드처럼 취급할 수 있는&lt;/p&gt;

        &lt;p&gt;여러 인터페이스를 구현해놓았다는 것을 알게 되었다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/java/2021/01/18/Functional_Programming.html&quot;&gt;https://isaac56.github.io/java/2021/01/18/Functional_Programming.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스의 길찾기 게임과 카펫 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;길찾기 게임:
        &lt;ul&gt;
          &lt;li&gt;단순한 구현 문제이다.&lt;/li&gt;
          &lt;li&gt;y값으로 내림차순 정렬을 한 후 이진 탐색 트리에 삽입한다.&lt;/li&gt;
          &lt;li&gt;pre-order, post-order 순서로 각각 탐색한 후 결과를 반환한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;카펫:
        &lt;ul&gt;
          &lt;li&gt;단순한 완전탐색 문제이다.&lt;/li&gt;
          &lt;li&gt;yellow의 형태에 따라 결정되는 brown갯수를 알면 쉽다.&lt;/li&gt;
          &lt;li&gt;주어진 yellow개수로 취할수 있는 yellow의 형태를 바꿔가며 brown개수가 일치하는 순간 답을 반환한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP/IP 쉽게 30페이지까지 읽었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;각각 계층이 자신의 역할만 하고 나머지는 다른 계층에 위임한다.&lt;/li&gt;
      &lt;li&gt;이런 위임을 통해 마치 자신의 계층만 있는 것처럼 통신할 수 있다.&lt;/li&gt;
      &lt;li&gt;애플리케이션 계층, 트랜스포트 게층, 인터넷 계층, 네트워크 인터페이스 계층에서 사용하는 프로토콜들을 확인하였다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바에서 함수형 프로그래밍을 위해 꼭 Functional Interface를 사용해야하는 건지 모르겠다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;미션에서 주어진 조건을 만족하기 위해서는 굳이 Functional Interface가 필요한지 모르겠다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;함수형 프로그래밍으로 Refactoring하는 목적에 코드의 간소화도 있을텐데, Functional Interface를 남발하면&lt;/p&gt;

        &lt;p&gt;코드가 더 복잡해지는 것 같다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP/IP 책을 읽었는데 엄청 꼼꼼하게 읽기보다 쓱쓱 여러번 읽는 방향으로 진행하려고 한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;부담없이 쓱쓱 읽으니까 잘 읽히고, 좋다.&lt;/li&gt;
      &lt;li&gt;여러번 읽음으로써 체득하려고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 마스터즈 수업듣기&lt;/li&gt;
  &lt;li&gt;코드스쿼드 미션 개선해보기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Functional Interface" /><category term="Algorithm" /><category term="Network" /></entry><entry><title type="html">함수형 프로그래밍</title><link href="http://localhost:4000/java/2021/01/18/Functional_Programming.html" rel="alternate" type="text/html" title="함수형 프로그래밍" /><published>2021-01-18T00:00:00+09:00</published><updated>2021-01-18T00:00:00+09:00</updated><id>http://localhost:4000/java/2021/01/18/Functional_Programming</id><content type="html" xml:base="http://localhost:4000/java/2021/01/18/Functional_Programming.html">&lt;h2 id=&quot;함수형-프로그래밍이란&quot;&gt;함수형 프로그래밍이란?&lt;/h2&gt;

&lt;p&gt;함수형 프로그래밍은 프로그램을 수학적 함수의 조합으로 생각하는 방식이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 수학적 함수란, 수학의 함수와 같이 인풋을 받아 아웃풋을 반환하는 것을 말하며,&lt;/p&gt;

&lt;p&gt;같은 인풋일 때는 항상 같은 아웃풋을 반환해야 하고(순수 함수), 함수 외부의 값을 변경할 수 없다(불변성).&lt;/p&gt;

&lt;h2 id=&quot;함수형-프로그래밍의-이점&quot;&gt;함수형 프로그래밍의 이점?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Michael Feathers&lt;/strong&gt; ‘레거시 코드 활용 전략’ 저자&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;객체지향 프로그래밍에서는 각 객체안에 자신이 기능하기 위한 상태(변수)와 메소드 들이 캡슐화 되어있고,&lt;/p&gt;

&lt;p&gt;그러한 객체 간의 상호작용을 통해 프로그램이 동작하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 객체의 메소드는 객체안의 상태(멤버 변수)에 따라 같은 파라미터를 입력하더라도 결과값이 다를 수 있고,&lt;/p&gt;

&lt;p&gt;비동기 프로그래밍을 위해서는 특정 변수에 Lock을 걸어 스레드간의 충돌이 일어나지 않도록 신경써야 한다.&lt;/p&gt;

&lt;p&gt;즉, 객체의 상태에 따른 side effect를 주의하여야 하며, 여러 스레드에서 같은 상태(멤버 변수)에 접근하여 side effect가 발생하지 않도록 주의해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러나 함수형 프로그래밍에서 각 함수는 불변성과 순수 함수라는 특징을 갖기 때문에,&lt;/p&gt;

&lt;p&gt;멤버 변수의 변화나 여러 스레드의 접근에 따른 side effect를 걱정하지 않고 프로그래밍을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;함수형-프로그래밍의-컨셉&quot;&gt;함수형 프로그래밍의 컨셉&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;불변성과 순수함수라는 특징은 상태에 따른 Side Effect를 없애준다.&lt;/li&gt;
  &lt;li&gt;함수도 객체이다.&lt;/li&gt;
  &lt;li&gt;코드를 간결하게 하고 구현할 로직에 집중할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;불변성과-순수함수라는-특징은-상태에-따른-side-effect를-없애준다&quot;&gt;불변성과 순수함수라는 특징은 상태에 따른 Side Effect를 없애준다.&lt;/h3&gt;

&lt;p&gt;함수형 프로그래밍의 함수는 불변성(Immutablility)과 순수함수(Pure Function)이라는 특징이 있다.&lt;/p&gt;

&lt;p&gt;이러한 특징에 의해 함수는 상태에 영향을 받지 않기 때문에 상태에 따른 side effect를 걱정하지 않아도 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;불변성(Immutablility)&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;함수형 프로그래밍에서는 데이터가 변할 수 없는데, 이를 불변성 데이터라고 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;데이터 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터를 복사본을 만들어 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;불변성은 함수에 파라미터로 넘어온 값의 원본데이터는 변하지 않는다는 특징이다.&lt;/p&gt;

    &lt;p&gt;일반적인 Call by Value를 생각하면 이해하기 쉽고,&lt;/p&gt;

    &lt;p&gt;만약 자바의 인스턴스를 인자로 받을 경우 인스턴스의 복사본을 통해 작업을 진행해야 원본 데이터의 변경을 피할 수 있을 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순수 함수(Pure Function)&lt;/p&gt;

    &lt;p&gt;함수형 프로그래밍에서 함수는 자체적인 상태를 관리하지 않는다.&lt;/p&gt;

    &lt;p&gt;인자로 들어온 변수와 상수만을 이용하여 결과를 출력함으로써, 동일한 인풋일 때 항상 같은 결과임을 보장한다.&lt;/p&gt;

    &lt;p&gt;코드로 표현하면 아래와 같다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 함수형 프로그래밍에서는 아래와 같이&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 동일한 인자를 입력받으면 항상 동일한 결과를 반환하여야 한다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x=1, y=1일 경우 func는 항상 2를 반환한다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  
  
&lt;span class=&quot;c1&quot;&gt;// 객체지향 프로그래밍에서는 아래와 같이&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 동일한 인자를 입력받더라도 객체의 상태에 따라 다른 결과를 반환할 수 있다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 예제에서는 state가 변경될 때 발생할 수 있는 side effect를 주의하며 코딩해야 한다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;함수도-객체이다&quot;&gt;함수도 객체이다.&lt;/h3&gt;

&lt;p&gt;함수형 프로그래밍에서 함수는 1급 객체이다.&lt;/p&gt;

&lt;p&gt;1급 객체가 되려면 값으로 할당 할 수 있고, 파라미터로 다른 함수에 넘길 수 있고, 리턴값으로 반환할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;안타깝게도, 자바에서는 함수를 1급 객체로 취급하지 않기 때문에 함수(메소드)를 담은 인스턴스를 넘기는 방식으로&lt;/p&gt;

&lt;p&gt;메소드를 인자로 전달하거나 결과로 반환받을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다만 자바 8부터는 람다식을 통해, 마치 메소드를 인자로 넘기는 것처럼 인스턴스를 넘길 수 있게 되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바8부터 메소드가 하나뿐인 인터페이스는, 람다식으로 익명 클래스를 간단하게 선언할 수 있다.&lt;/li&gt;
  &lt;li&gt;실제 동작은 람다식으로 익명 클래스를 생성하고, 그 익명 클래스를 넘겨주는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예제는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 메소드가 하나뿐인 인터페이스만&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 람다식을 통해 익명 클래스로 선언될 수 있다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Calculator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CalcService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Calculator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;caculate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;CalcService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CalcService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//15출력&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드를-간결하게-하고-가독성을-높여-구현할-로직에-집중-시키자&quot;&gt;코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중 시키자.&lt;/h3&gt;

&lt;p&gt;아예 변경하지 않고 재사용하거나, 아주 일부만을 변경하여 재사용하는 코드들을 보일러 플레이트 코드라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, List에 있는 모든 변수들에 어떤 처리를 해주기 위해서는 List를 포문으로 순회하며 처리해야 한다.&lt;/p&gt;

&lt;p&gt;이때 “처리”에 해당하는 부분만 변경될 뿐 포문은 항상 재사용되기 때문에 포문을 보일러 플레이트 코드라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍에서는 “처리”에 해당하는 함수를 인자로 받는 고계함수를 만들어서 보일러 플레이트 코드를 없앨 수 있다.&lt;/p&gt;

&lt;p&gt;(고계함수는 함수를 처리하는 함수라는 뜻으로, 함수를 인자로 받아 사용하거나 함수를 반환하는 등의 행위를 할 수 있다.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, Integer의 List에 있는 모든 요소를 제곱으로 변경해보겠다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ForStatement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;ForStatement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forStatement&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ForStatement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 모든 요소가 제곱이 된 리스트&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;powList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forStatement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이처럼 ForStatement와 같은 클래스를 한번 정의해두면,&lt;/p&gt;

&lt;p&gt;앞으로 List 전체 요소를 변경할 일이 있을 때 for문을 작성할 필요 없이 간단하게 원하는 값으로 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, 함수형 프로그래밍에서는 핵심 로직(함수)만 인자로 넘겨줌으로써 코드를 간결하게 하고 로직에 집중할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;그리고 자바8부터는 stream과 Functional Interface를 제공하여 위와 같은 과정을 쉽게 구현할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://futurecreator.github.io/2018/08/26/java-8-streams/&quot;&gt;자바8 stream 사용법&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://codechacha.com/ko/java8-functional-interface/&quot;&gt;Functional Interface 사용법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><category term="Java" /><category term="Functinal Programming" /></entry><entry><title type="html">21년 1월 17일</title><link href="http://localhost:4000/til/2021/01/17/TIL14.html" rel="alternate" type="text/html" title="21년 1월 17일" /><published>2021-01-17T00:00:00+09:00</published><updated>2021-01-17T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/17/TIL14</id><content type="html" xml:base="http://localhost:4000/til/2021/01/17/TIL14.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;2주만에 처음으로 아무것도 안하고 쉬고 말았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;계획에 없던 휴식이었다. 정말 아무것도 안해버렸다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;목이 좀 뻐근했던 것이 핑계였는지 오늘은 아무것도 하기싫었다 ..&lt;/li&gt;
  &lt;li&gt;내일부터 다시 제대로 마음먹고 시작해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;10시~18시: 코드스쿼드 미션 진행하기&lt;/li&gt;
  &lt;li&gt;19시~22시:  프로그래머스 알고리즘 풀기&lt;/li&gt;
  &lt;li&gt;22시~23시30분: TCP/IP 쉽게 더 쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Rest" /></entry><entry><title type="html">21년 1월 16일</title><link href="http://localhost:4000/til/2021/01/16/TIL13.html" rel="alternate" type="text/html" title="21년 1월 16일" /><published>2021-01-16T00:00:00+09:00</published><updated>2021-01-16T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/16/TIL13</id><content type="html" xml:base="http://localhost:4000/til/2021/01/16/TIL13.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;프로그래머스 외벽점검에서 같은 BFS라도 어떤 기준으로 푸느냐에 따라 오답이 될 수 있는 이유를 알아내었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;글로 설명하긴 어렵다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;외벽점검 문제에서 weak포인트 배열을 기준으로 BFS를 돌리는데 첫 시작을 제일 능력있는 친구를 넣어놓고,&lt;/p&gt;

            &lt;p&gt;그 다음부터 아무 친구씩 다음 weak포인트에 배치하는 식으로 돌리면 속도가 빠르다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;자바로 풀었던 방법은 dist 배열(친구들)을 기준으로 BFS를 돌리는데 첫 시작을 제일 능력있는 친구를 넣는건 같지만,&lt;/p&gt;

            &lt;p&gt;다음으로 능력있는 친구를 아무 weak포인트에 배치하게 풀어서 경우의 수가 너무 많아지고 시간초과로 오답이 된다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;이 문제를 C++로 풀었을 때는 쉽게 풀었었는데, 다시 풀다보니까 BFS돌리는 기준을 잘못 잡아서 시간초과로 틀렸다.&lt;/li&gt;
          &lt;li&gt;처음 이 문제를 만났을 때, DFS 또는 BFS로 풀어야 한다는 생각은 들지만 위의 사소한 조건을 딱 맞혀서 풀 자신이 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;오늘은 거북목 때문인지 목이 너무 뻐근해서 하루를 쉬어버렸다..&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

    &lt;ul&gt;
      &lt;li&gt;하루를 쉬고 공부를 못했다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

    &lt;ul&gt;
      &lt;li&gt;길게 보고 꾸준히 하기 위해서 아플때 쉬는 건 잘한 것 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

    &lt;ul&gt;
      &lt;li&gt;지금 내 실력으로 실제 코테에서 외벽점검같은 문제를 만났을 때 정답을 맞히는건 운이 좀 필요할 것 같다.&lt;/li&gt;
      &lt;li&gt;실력이 좋아진다면 문제를 보고 설계하는 단계에서 저런 정확한 방법을 찾을 수 있을까 잘 모르겠다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

    &lt;ul&gt;
      &lt;li&gt;프로그래머스 알고리즘 풀기&lt;/li&gt;
      &lt;li&gt;TCP/IP 쉽게 더 쉽게 읽기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /><category term="Rest" /></entry><entry><title type="html">21년 1월 15일</title><link href="http://localhost:4000/til/2021/01/15/TIL12.html" rel="alternate" type="text/html" title="21년 1월 15일" /><published>2021-01-15T00:00:00+09:00</published><updated>2021-01-15T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/15/TIL12</id><content type="html" xml:base="http://localhost:4000/til/2021/01/15/TIL12.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 객체지향적으로 프로그래밍 하기를 완성했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;접근제한자 중 protected는 본인 또는 상속받은 class만 접근 가능한 줄 알았다..(같은 패키지 또는 상속받은 클래스였다.)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도형이라는 추상클래스를 만들고 멤버변수로 점의 배열, 추상메소드로 isValid, getSize, getSizeString을 넣었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도형을 상속받은 선, 삼각형, 직사각형 등은 isValid를 통해 해당 점으로 본인이 생성 가능한지 판단하고,&lt;/p&gt;

        &lt;p&gt;아니라고 판단하면 Exception을 throw하게 했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도형이라는 추상클래스 안에 static 메소드로 getInstance를 만들어 입력 받은 점의 배열의 갯수에 따라,&lt;/p&gt;

        &lt;p&gt;2개면 선, 3개면 삼각형, 4개는 사각형을 반환하도록 하고, try catch문으로 해당 instance 생성에 Exception이&lt;/p&gt;

        &lt;p&gt;발생하면 null을 반환하게 하였다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 외벽점검 문제를 다양하게 풀어봤다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;C++을 풀었던 답을 자바로 재현해봤더니 조금 느리긴 했지만 큰 차이는 없었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;문제에서 주어진 weak 또는 dist 둘 중 하나를 기준으로 BFS 돌리면 dist를 기준으로 했을 때 훨씬 빨랐다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;또 BFS 중 queue에서 뽑으면서 행위를 하느냐, 행위를 하고 queue에 넣느냐에 따라 시간이 달랐다.&lt;/p&gt;

        &lt;p&gt;(이 문제에서는 queue에 뽑으면서 행위를 하는게 더 빨랐다.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;뭔가 집중을 하면, 다른 일로 전환이 잘 안된다.&lt;/li&gt;
  &lt;li&gt;오늘도 코테 공부하다가 책도 못읽었다.&lt;/li&gt;
  &lt;li&gt;시간을 정해놓고 의식적으로 안되면 끊고 다음 일 하기를 연습해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;그래도 꾸준히 성실하게 공부하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자바로 풀어서 틀린게 아니었다, 로직이 틀린 것이었다.&lt;/li&gt;
  &lt;li&gt;같은 BFS인데도 어떤걸 기준으로 잡느냐에 따라 답이다르고, 행위를 queue에서 뺄때 또는 넣기 전에 하느냐에 따라 속도가 달랐다.
    &lt;ul&gt;
      &lt;li&gt;아직 왜 이런 차이가 생기는지 모르겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;할 일이 산더미다 ㅠㅠ 코딩 테스트만 좀 잘한다면 코테말고 다른 공부를 하고 싶다.&lt;/li&gt;
  &lt;li&gt;학습방법 등에 대한 JK의 강의를 들었는데, 어제의 나보다 오늘의 내가 성장했냐를 판단한다면 아직은 잘 모르겠다.&lt;/li&gt;
  &lt;li&gt;내 학습방법에 대해 의심을 해봐야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 알고리즘 풀기&lt;/li&gt;
  &lt;li&gt;외벽점검 문제 푸는 방법에 따른 속도차이 생각해보기&lt;/li&gt;
  &lt;li&gt;자바의정석 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /><category term="OOP" /></entry><entry><title type="html">21년 1월 14일</title><link href="http://localhost:4000/til/2021/01/14/TIL11.html" rel="alternate" type="text/html" title="21년 1월 14일" /><published>2021-01-14T00:00:00+09:00</published><updated>2021-01-14T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/14/TIL11</id><content type="html" xml:base="http://localhost:4000/til/2021/01/14/TIL11.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 객체지향적으로 프로그래밍 하기를 해봤다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;입력으로 (x, y) 좌표들을 받는다.&lt;/li&gt;
      &lt;li&gt;좌표가 2개면 선의 길이, 좌표가 3개면 삼각형 넓이, 좌표가 4개면 직사각형 넓이(직사각형인지 검사)를 출력한다.&lt;/li&gt;
      &lt;li&gt;점부터, 선, 삼각형, 직사각형 등을 클래스로 설계하고 상속과 다형성을 사용하여 객체지향적으로 프로그래밍해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;미션을 끝까지 하지 못했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;삼각형과 직사각형은 도형이라는 추상클래스를 공통 부모 클래스로 두면 될 것 같은데,&lt;/p&gt;

        &lt;p&gt;선은 삼각형이나 직사각형과 전혀 달라서 설계가 안된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;도형이라는 추상클래스에 높이, 너비, 넓이를 구하는 메소드를 정의하고 삼각형과 직사각형은 이를 오버라이드하게 하였다.&lt;/li&gt;
      &lt;li&gt;선은 단순히 길이를 구할 뿐인데, 선은 도형과 전혀 다르지 않나?? 선,삼각형,직사각형 세 타입을 어떻게 묶어야 하는지 모르겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OOP의 기본개념을 정리하여 포스팅하였다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/java/2021/01/14/OOP_basic_concept.html&quot;&gt;https://isaac56.github.io/java/2021/01/14/OOP_basic_concept.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 기둥과 보 설치 문제를 풀었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;단순 시뮬레이션 문제였다.&lt;/li&gt;
      &lt;li&gt;푸는 방법보다 구현이 복잡한 문제여서, 꼼꼼하게 경우의 수를 생각하고 꼼꼼한 코딩을 해야 하는 문제이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 외벽점검 문제 풀기 실패하였다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;C++로 BFS를 통해 풀었던 문제인데, 자바로 BFS를 통해 풀었더니 시간초과가 난다.&lt;/li&gt;
      &lt;li&gt;BFS로 푸는과정에서 예전과 로직이 달라서 시간초과인지, 자바로 풀어서 시간초과가 난건지(그럴 확률은 낮지만) 내일 확인하려한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;저녁에 코딩테스트 공부가 길어지다보니, 계획했던 다른 공부를 전혀 하지 못한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;알고리즘을 자바로 푸는게 맞는가 확신이 들지 않는다. ㅠㅠ&lt;/li&gt;
  &lt;li&gt;전에 풀었던 외벽점검 C++ 답과 똑같은 로직을 자바로 구현하여 시간을 재볼 것이다.&lt;/li&gt;
  &lt;li&gt;똑같은 로직인데도 자바가 시간초과가 난다면, 파이썬이나 C++로 옮길 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 진행&lt;/li&gt;
  &lt;li&gt;프로그래머스 알고리즘 풀기&lt;/li&gt;
  &lt;li&gt;외벽점검 문제 C++ 답안과 동일하게 자바로 구현해보기&lt;/li&gt;
  &lt;li&gt;자바의정석 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /><category term="OOP" /></entry></feed>