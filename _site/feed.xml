<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-02-08T17:43:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">gradle 프로젝트에서 JUnit Test시 에러 발생</title><link href="http://localhost:4000/gradle/2021/02/08/gradle_project_JUnit_Error.html" rel="alternate" type="text/html" title="gradle 프로젝트에서 JUnit Test시 에러 발생" /><published>2021-02-08T00:00:00+09:00</published><updated>2021-02-08T00:00:00+09:00</updated><id>http://localhost:4000/gradle/2021/02/08/gradle_project_JUnit_Error</id><content type="html" xml:base="http://localhost:4000/gradle/2021/02/08/gradle_project_JUnit_Error.html">&lt;h3 id=&quot;intellij의-gradle-프로젝트에서-평소와-같이-junit-test를-실행시켰다&quot;&gt;IntelliJ의 Gradle 프로젝트에서 평소와 같이 JUnit Test를 실행시켰다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;아래와 같은 에러가 발생했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FAILURE: Build failed with an exception.
* What went wrong:
Execution failed for task ':test'.
&amp;gt; No tests found for given includes: [net.honux.chess.PawnTest.test]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Gradle프로젝트에서 JUnit을 실행시키기 위해서는 build.gradle 파일에 test라는 task를 추가해줘야 한다고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gradle-docs를-참조하여-buildgradle에-test-task를-추가해-보았다&quot;&gt;Gradle Docs를 참조하여 build.gradle에 Test Task를 추가해 보았다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gradle Docs에서 JUnit을 사용하려면 build.gradle 파일에 아래 내용을 추가하라고 한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test {
  useJUnitPlatform()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이번엔 아래와 같은 에러가 발생했다. (useJUnitPlatform() 를 인식못한다.)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caused by: org.gradle.internal.metaobject.AbstractDynamicObject$CustomMessageMissingMethodException:  
Could not find method useJUnitPlatform() for arguments [] on task ':test' of type org.gradle.api.tasks.testing.Test.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;현재-프로젝트의-gradle-wrapper에-있는-gradle-버전이-문제였다&quot;&gt;현재 프로젝트의 gradle wrapper에 있는 gradle 버전이 문제였다.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트 폴더 - gradle - wrapper - gradle-wrapper.properties 에서 현재 프로젝트의 gradle 버전을 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;나는 gradle 버전이 3.4.1이었다 ㅠㅠ&lt;/li&gt;
  &lt;li&gt;위에 추가하려던 내용은 6.8.2 버전에서 사용할 수 있는 명령어였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;해결방법&quot;&gt;해결방법&lt;/h1&gt;

&lt;h2 id=&quot;1-gradle-버전-변경후-buildgradle-파일-수정&quot;&gt;1. Gradle 버전 변경후 build.gradle 파일 수정&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. Gradlew 명령어를 통한 버전 변경&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Gradle 버전을 변경하려는 프로젝트로 이동한 후 Gradlew 명령어를 통해 버전을 변경한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ./gradlew wrapper --gradle-version [변경버전]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/2V5hL/btqDdIBnh68/0GMUJKgxSnwr8AV5WuMA9K/img.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 변경된 버전&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;변경 완료 후 gradle/wrapper/gradle-wrapper.properties에서 변경된 버전을 확인한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/d1EMdT/btqDbFZViw7/cXSAm9K5V7gOEGvuyMt3ok/img.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;출처 &lt;a href=&quot;https://twofootdog.tistory.com/56&quot;&gt;https://twofootdog.tistory.com/56&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. build.gradle 파일에 아래 내용 추가&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dependencies {
    testCompile(&quot;org.junit.jupiter:junit-jupiter-api:5.6.0&quot;)
    testRuntime(&quot;org.junit.jupiter:junit-jupiter-engine&quot;)
}

test {
    useJUnitPlatform()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-341버전에-맞는-내용-buildgradle에-추가하기&quot;&gt;2. 3.4.1버전에 맞는 내용 build.gradle에 추가하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;3.4.1 버전에 맞는 test task코드를 추가하려 했으나, JUnit 5는 gradle 4.7이상부터 지원한다고 한다..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-project-setting에서-gradle이-아닌-intellij를-사용하여-test하도록-수정하기&quot;&gt;3. Project Setting에서 Gradle이 아닌 IntelliJ를 사용하여 test하도록 수정하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Preferences(설정) -&amp;gt; Build, Execution, Deployment -&amp;gt; Gradle에서 [Run tests using:] 항목을 IntelliJ로 수정한 후 실행시켜준다.&lt;/li&gt;
  &lt;li&gt;이렇게 하는 것은 gradle 프로젝트의 사용 목적에 맞지 않아 추천하지 않는다고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;That’s “plan B”, but Gradle won’t rebuild that from scratch. Said otherwise, if you count on Gradle so someone else can use your project, don’t do that, or make sure to push the IntelliJ project in your repo, but that defeats the purpose of using Gradle…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;출처 - &lt;a href=&quot;https://stackoverflow.com/questions/30474767/no-tests-found-for-given-includes-error-when-running-parameterized-unit-test-in&quot;&gt;https://stackoverflow.com/questions/30474767/no-tests-found-for-given-includes-error-when-running-parameterized-unit-test-in&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```&lt;/p&gt;</content><author><name></name></author><category term="gradle" /></entry><entry><title type="html">gradle이란 무엇일까</title><link href="http://localhost:4000/gradle/2021/02/08/what_gradle.html" rel="alternate" type="text/html" title="gradle이란 무엇일까" /><published>2021-02-08T00:00:00+09:00</published><updated>2021-02-08T00:00:00+09:00</updated><id>http://localhost:4000/gradle/2021/02/08/what_gradle</id><content type="html" xml:base="http://localhost:4000/gradle/2021/02/08/what_gradle.html">&lt;h2 id=&quot;gradle이란&quot;&gt;Gradle이란?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gradle은 groovy 언어를 이용한 빌드 자동화 시스템이다. Ant와 Maven과 같은 이전 빌드 도구들의 장점을 모아 만든 오픈소스 빌드 도구이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트 설정이나 의존 라이브러리 등 빌드에 필요한 정보를 gradle로 설정해 놓으면, 다른 환경에서 프로젝트를 불러도 빌드에 필요한 것들을 알아서 설정해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;심지어 Maven의 pom.xml을 Gradle용으로 변환할 수도 있으며 Maven의 중앙저장소도 지원하기 때문에 필요한 라이브러리를 가져다 사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gradle-wrapper&quot;&gt;gradle wrapper&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;이미 존재하는 프로젝트를 새로운 환경에 설치할때 별도의 설치나 설정과정없이 곧 바로 빌드할 수 있게 해준다.&lt;/p&gt;

    &lt;p&gt;(Java나 Gradle도 설치할 필요가 없다. gradle wrapper를 이용하면 로컬에 설치된 Java와 gradle 버전을 신경쓸 필요 없이 wrapper에 포함된 java와 gradle을 사용하는 듯 하다)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;wrapper는 사용자가 Gradle이 설치되어 있지 않아도 Gradle tasks를 실행할 수 있도록 해주는 작은 script, jar 및 등록 정보 파일&lt;/li&gt;
  &lt;li&gt;wrapper를 생성하면 사용자가 프로젝트를 만든 사람과 동일한 버전의 Gradle을 사용할 수 있음&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;gradle wrapper 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gradle wrapper

BUILD SUCCESSFUL &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;602ms
1 actionable task: 1 executed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 파일이 만들어짐&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
└── gradlew.bat

2 directories, 5 files
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./gradlew build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wrapper를 사용하면 위와 같이 실행가능&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gradle build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 경우 Java나 Gradle이 설치되어 있어야 하고, 새로받은 프로젝트의 Gradle 버전과 로컬에 설치된 Gradle 버전이 호환되지 않으면 문제가 발생할 수 있음&lt;/p&gt;

&lt;p&gt;또, gradle명령어로 컴파일이나 빌드 등을 할때, 위와 같이 하면 로컬에 설치된 gradle을 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Build 후에는 test, compile 후 jar파일 생성&lt;/li&gt;
  &lt;li&gt;gradlew라는 UNIX script와 gradlew.bat라는 Windows명령이 jar 파일 및 속성 파일과 함께 생성됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://velog.io/@hwany/gradle&quot;&gt;https://velog.io/@hwany/gradle&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="gradle" /></entry><entry><title type="html">21년 2월 3일</title><link href="http://localhost:4000/til/2021/02/03/TIL.html" rel="alternate" type="text/html" title="21년 2월 3일" /><published>2021-02-03T00:00:00+09:00</published><updated>2021-02-03T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/02/03/TIL</id><content type="html" xml:base="http://localhost:4000/til/2021/02/03/TIL.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 보석쇼핑와 여행경로 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;보석쇼핑&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;HashSet을 이용하여 보석 종류의 개수를 구한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;이전 풀이에서 구간의 길이를 고정하던 것을 최소 길이로 변화하며 찾도록 하였더니 풀렸다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;HashMap&amp;lt;String, Integer&amp;gt;인 hashMap을 준비한다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;발견된 최소 길이인 int 변수 minRange를 두고, gems.length + 1로 초기화시킨다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;start변수와 end변수를 두고 둘다 0을 초기값으로 가진다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;end변수가 gems의 마지막 index까지 증가하며 while문을 돈다.&lt;/p&gt;

                &lt;ol&gt;
                  &lt;li&gt;
                    &lt;p&gt;hashMap에서 end index에 해당하는 보석이름의 Value를 1 증가시킨다.&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;hashMap에서 start 보석이름의 value가 2이상인 동안, 보석이름의 value를 1 감소시키고 start를 증가시킨다.&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;현재 hashMap의 size가 총 보석 종류의 개수와 일치하고, end-start+1값이 minRange보다 작으면&lt;/p&gt;

                    &lt;p&gt;end와 start를 저장한다.&lt;/p&gt;
                  &lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;while문이 끝난후 저장되어있던 start와 end가 정답이 된다.&lt;/p&gt;

                &lt;p&gt;(문제에서 기준이 1부터 시작하므로 new int[]{start+1,end+1}을 반환)&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;여행경로&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;정렬이 포함된 DFS문제였다.&lt;/li&gt;
          &lt;li&gt;모든 여행티켓을 사용한 경로를 DFS로 구해야 한다.&lt;/li&gt;
          &lt;li&gt;하지만 경로가 여러개일 경우 알파벳 순사가 앞서는 경로를 출력해야한다.&lt;/li&gt;
          &lt;li&gt;여행티켓을 알파벳 순서로 정렬한 후에, DFS로 구하면 간단하게 정답이 구해진다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Stream 부분을 읽었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석 Stream을 읽는데 집중이 안되서 정독하지 못했다.&lt;/li&gt;
  &lt;li&gt;시간이 부족하여 네트워크 공부를 하지못했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘에 자신감이 붙기 시작했다.&lt;/li&gt;
  &lt;li&gt;코딩테스트에 감이 생겼다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;오늘도 시간이 훅 가버렸다.&lt;/li&gt;
  &lt;li&gt;오랜만에 코드스쿼드 미션이 없는 날이라 개인공부를 하려고했는데 많이 하지 못했다 ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;자바의 정석 읽기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Network" /><category term="Algorithm" /></entry><entry><title type="html">21년 2월 2일</title><link href="http://localhost:4000/til/2021/02/02/TIL.html" rel="alternate" type="text/html" title="21년 2월 2일" /><published>2021-02-02T00:00:00+09:00</published><updated>2021-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/02/02/TIL</id><content type="html" xml:base="http://localhost:4000/til/2021/02/02/TIL.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;소켓 통신을 사용하여 HttpRequest와 HttpResponse 객체 구현하기&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;URL 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;URL 객체를 생성할 때, url string값을 인자로 넣어준다.&lt;/li&gt;
          &lt;li&gt;생성자에서 url을 파싱하여 protocol, domain, path, port를 프로퍼티로 저장한다.&lt;/li&gt;
          &lt;li&gt;생성자에서 InetAddress를 사용하여 DNS서버로부터 호스트 IP를 받아온다(DNS Look up)&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HttpRequest 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;URL 객체를 인자로 생성할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Request메소드에 [GET, POST, UPDATE, DELETE] Method값(enum)과 body(JsonObject)를 넣어준다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;인스턴스의 URL과 인자로 받은 Method값, body를 조합하여 기본적인 Http 요청 String을 만든다.&lt;/li&gt;
              &lt;li&gt;URL의 IP와 포트번호를 기준으로 Socket 연결한다.&lt;/li&gt;
              &lt;li&gt;Socket 통신을 통해 만들어놓은 Http 요청을 보낸다.&lt;/li&gt;
              &lt;li&gt;Socket으로 들어온 Response를 BufferedReader로 읽으며 HttpResponse를 생성한다.
                &lt;ul&gt;
                  &lt;li&gt;처음 등장하는 빈 줄을 기준으로 header와 body를 나눈다.&lt;/li&gt;
                  &lt;li&gt;response header에 Content-Length가 있으면 Content-Length개 만큼 body를 읽는다.&lt;/li&gt;
                  &lt;li&gt;Content-Length가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;값이 나올때까지 body를 읽는다.&lt;/li&gt;
                  &lt;li&gt;다 읽으면 바로 socket 연결을 끊는다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;생성한 HttpResponse를 반환한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HttpResponse 객체를 만들었다.&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;header String(포맷에 맞아야 함)과 body String을 파라미터로 생성할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;그냥 생성할 경우, setHeader(String header) 와 setBody(String body)로 Response를 만들어줘야한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;header String 을 파싱하여 protocol, statusCode, statusMessage를 생성하며, 나머지 헤더값은&lt;/p&gt;

            &lt;p&gt;Map&amp;lt;String, String&amp;gt; 형태로 저장한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 보석쇼핑 문제 풀기에 실패했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HashSet을 이용하여 보석 종류의 개수를 구한다.&lt;/li&gt;
      &lt;li&gt;기본적으로 길이가 j 인 구간에서 모든 종류가 있는지 확인할 땐 sliding window기법을 사용했다.
        &lt;ol&gt;
          &lt;li&gt;HashMap&amp;lt;String, Integer&amp;gt;을 사용한다.&lt;/li&gt;
          &lt;li&gt;1번째부터 j번째까지 돌며 HashMap에서 보석의 value를 1씩 증가시킨다.&lt;/li&gt;
          &lt;li&gt;HashMap의 크기가 보석종류의 개수와 같으면 현재 구간을 반환한다.&lt;/li&gt;
          &lt;li&gt;j+1번째부터 마지막까지 순회하며
            &lt;ol&gt;
              &lt;li&gt;직전 구간 첫번째 보석의 value를 1 감소시키고, value가 0이면 HashMap에서 삭제한다.&lt;/li&gt;
              &lt;li&gt;새로 포함된 보석의 value를 1 증가시킨다.&lt;/li&gt;
              &lt;li&gt;HashMap의 크기가 보석종류의 개수와 같으면 현재 구간을 반환한다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;끝까지 답을 못찾으면 null을 반환한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;정답 구간의 길이 최대값은 gems의 개수, 최소값은 보석종류의 개수이다.&lt;/li&gt;
      &lt;li&gt;binarySearch로 정답 구간의 길이를 찾아가며 최소 길이의 구간을 찾아낸다.&lt;/li&gt;
      &lt;li&gt;효율성에서 1개 빼고 모두 실패하였다. 방법 자체를 다시 생각해봐야겠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;HttpRequest와 HttpResponse를 내가 할수있는데까지 잘 구현하였다.&lt;/li&gt;
  &lt;li&gt;네트워크에 대해 자신감이 없었는데 이번에 아주 재밌게 실습하고 배웠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석 읽기&lt;/li&gt;
  &lt;li&gt;네트워크 공부하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Network" /><category term="Algorithm" /></entry><entry><title type="html">21년 2월 1일</title><link href="http://localhost:4000/til/2021/02/01/TIL.html" rel="alternate" type="text/html" title="21년 2월 1일" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/02/01/TIL</id><content type="html" xml:base="http://localhost:4000/til/2021/02/01/TIL.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바 소켓통신으로 Http 요청을 구현해보았고 성공적인 Response를 받을 수 있었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;URL 클래스를 직접 구현하여, http://www.naver.com:80/test?query=test 와 같은 형식의 url을&lt;/p&gt;

        &lt;p&gt;프로토콜, 도메인 이름, uri, 파라미터등으로 구분하도록 하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;URL클래스 내부적으로 java.net의 InetAddress 클래스를 이용하여 DNS서버에서 IP주소를 알아낸다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;직접 구현한 URL 클래스를 이용하여 http 헤더를 붙여서 소켓통신으로 http request를 보내고 response를 받아온다.(내일 예정)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP/IP 4계층 모델에 대하여 공부 및 포스팅 하였다. (이번 내용은 정보를 서술할 뿐이라 다른 글을 거의 복사했다.)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/network/2021/02/01/TCP-IP_4_layer.html&quot;&gt;TCP/IP 4계층 모델&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 징검다리건너기 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;징검다리건너기&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;각 돌은 건널 수 있는 숫자가 정해져있고(일정 숫자 이상 밟으면 부서진다고 상상), 최대로 점프할 수 있는 거리는 k로 제한된다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;내 풀이:&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;한번에 뛸 수 있는 거리는 k이므로, stones를 전체 순회하며 k 길이만큼의 구간이 사용 가능한 횟수를 구한다.&lt;/p&gt;

                &lt;p&gt;ex) 1~k 구간이 버틸 수 있는 사람 수는 1~k번째 돌에 적힌 숫자 중 최대값이며, 그 다음은 2~k+1번째 구간의 값을 구한다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;이렇게 구한 값중 최소값이 징검다리를 건널 수 있는 최대 인원이다.(k개의 구간이 무너지는 순간 아무도 건널 수 없으므로)&lt;/li&gt;
              &lt;li&gt;결국 구간 max값을 stones길이만큼 구해야 하는데, 효율성 통과를 위해 구간값을 segment tree로 구했다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;다른 사람 풀이:&lt;/p&gt;
            &lt;ol&gt;
              &lt;li&gt;징검다리 건널 수 있는 최대 인원은, 돌에 적힌 숫자 중 최대값과 최소값의 사이이다.&lt;/li&gt;
              &lt;li&gt;binary search로 answer를 바꿔가며, 정답을 찾는다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크는 대학교때도 꺼려했던 과목이라 기본이 많이 부족하다.&lt;/li&gt;
  &lt;li&gt;기본이 부족한데도 조급함을 느끼며 빨리빨리 하려고 했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다시 일상으로 복귀하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;조바심을 느껴 쓱 훑고 빨리 구현하려고 하니, 아무것도 하지 못한 느낌이다.&lt;/li&gt;
  &lt;li&gt;기본이 부족하면 차근차근 공부해야겠다. 시간은 많다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;네트워크 공부하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Network" /><category term="Algorithm" /></entry><entry><title type="html">TCP/IP 4계층</title><link href="http://localhost:4000/network/2021/02/01/TCP-IP_4_layer.html" rel="alternate" type="text/html" title="TCP/IP 4계층" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>http://localhost:4000/network/2021/02/01/TCP:IP_4_layer</id><content type="html" xml:base="http://localhost:4000/network/2021/02/01/TCP-IP_4_layer.html">&lt;h2 id=&quot;tcpip-4계층&quot;&gt;TCP/IP 4계층&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;계층모형
&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;계층모형은 컴퓨터들이 정보를 주고받는데 사용하는 프로토콜들을, 각 역할에 맞게 계층으로 나누어 분류한 집합이다.&lt;/p&gt;

  &lt;p&gt;이렇게 역할에 따라 계층을 나눔으로써, 서로 간의 간섭을 최소화하고 사용의 편리성을 높인다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;호환성 보장 (다른 제조사 장비들끼리도 통신 가능)으로 인한 비용 절감&lt;/li&gt;
    &lt;li&gt;문제 발견이 쉬워짐 (어떤 계층에서 문제가 있는지 확인 가능)&lt;/li&gt;
    &lt;li&gt;다른 계층의 전달 과정을 알 필요가 없어 해결해야할 문제가 단순해짐&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;국제표준화기구 IOS(International Organization for Standardization)에서는 상호 이질적인 네트워크간의 연결에서 호환성의 결여를 막기위해 OSI(Open Systems Interconnection) 모형을 개발했다.&lt;/li&gt;
  &lt;li&gt;실제 사용되는 TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형이다
    &lt;ul&gt;
      &lt;li&gt;네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준이 TCP/IP 4계층이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OSI 7계층을 4-5계층으로 분류하여 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4계층-요약&quot;&gt;4계층 요약&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;TCP/IP 4계층&lt;/th&gt;
      &lt;th&gt;역할&lt;/th&gt;
      &lt;th&gt;데이타 단위&lt;/th&gt;
      &lt;th&gt;전송 주소&lt;/th&gt;
      &lt;th&gt;예시&lt;/th&gt;
      &lt;th&gt;장비&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;응용 계층(Application)&lt;/td&gt;
      &lt;td&gt;응용프로그램 간의 데이타 송수신&lt;/td&gt;
      &lt;td&gt;Data/Message&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;전송 계층(Transport)&lt;/td&gt;
      &lt;td&gt;호스트 간의 자료 송수신&lt;/td&gt;
      &lt;td&gt;Segment&lt;/td&gt;
      &lt;td&gt;Port&lt;/td&gt;
      &lt;td&gt;TCP, UDP, RTP, RTCP 등&lt;/td&gt;
      &lt;td&gt;게이트웨이&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;인터넷 계층(Internet)&lt;/td&gt;
      &lt;td&gt;데이타 전송을 위한 논리적 주소 지정 및 경로 지정&lt;/td&gt;
      &lt;td&gt;Packet&lt;/td&gt;
      &lt;td&gt;IP&lt;/td&gt;
      &lt;td&gt;IP, ARP, ICMP, RARP, OSPF&lt;/td&gt;
      &lt;td&gt;라우터&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;네트워크 연결 계층(Network Access)&lt;/td&gt;
      &lt;td&gt;실제 데이타인 프레임을 송수신&lt;/td&gt;
      &lt;td&gt;Frame&lt;/td&gt;
      &lt;td&gt;MAC&lt;/td&gt;
      &lt;td&gt;Ethernet, PPP, Token Ring 등&lt;/td&gt;
      &lt;td&gt;브리지, 스위치&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;l4-응용-계층application-layer&quot;&gt;L4 응용 계층(Application Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: Data/Message&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다&lt;/li&gt;
  &lt;li&gt;응용프로그램(application)들이 데이터를 교환하기 위해 사용되는 프로토콜&lt;/li&gt;
  &lt;li&gt;사용자 응용프로그램 인터페이스를 담당&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;l3-전송-계층transport-layer&quot;&gt;L3 전송 계층(Transport Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: Segment
&lt;strong&gt;전송 주소&lt;/strong&gt;: Port&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신 노드 간의 연결 제어 및 자료 송수신을 담당&lt;/li&gt;
  &lt;li&gt;애플리케이션 계층의 세션과 데이터그램 통신서비스 제공&lt;/li&gt;
  &lt;li&gt;세그먼트 (Segment)단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;실질적인 데이터 전송을 위해 데이타를 일정 크기로 나눈 것. 발신, 수신, 포트주소, 오류검출코드가 붙게된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-1&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;TCP, UDP, RTP, RTCP 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP의 혼잡 방지 알고리즘&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;흐름 제어(Flow Control)&lt;/p&gt;

        &lt;p&gt;송신측과 수신측의 데이터처리 속도 차이를 해결하기 위한 기법이다.&lt;/p&gt;

        &lt;p&gt;수신측이 송신측보다 속도가 빠른것은 아무런 문제가 되지 않지만, &lt;strong&gt;송신측이 수신측보다 속도가 빠르면 문제가 발생한다.&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;수신측에서 수신된 데이터를 처리해서 윗 계층으로 서비스 하는 속도보다 송신측에서 보내는 데이터 속도가 더 빠르다면, 수신측에서 제한된 저장용량(일반적으로 큐)을 초과하여 이후에 도착하는 데이터의 손실을 가져올 수있다.&lt;/p&gt;

        &lt;p&gt;그렇다면 불필요하게 응답과 재전송의 데이터가 다시 송신측과 수신측간에 비번히 이동해야한다.&lt;/p&gt;

        &lt;p&gt;따라서, 이러한 위험을 줄이기 위해 &lt;strong&gt;강제로 송신측의 데이터 전송을 줄인다&lt;/strong&gt;.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Stop and wait 방식&lt;/p&gt;

            &lt;p&gt;매번 전송한 패킷에 대해 확인응답을 받아야만 그 다음 패킷을 전송하는 방법&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;슬라이딩 윈도우 기법&lt;/p&gt;

            &lt;p&gt;수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법이다.&lt;/p&gt;

            &lt;p&gt;이 처럼 슬라이딩 윈도우 기법을 통하여 &lt;strong&gt;송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜&lt;/strong&gt;으로써 흐름제어를 수행한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;혼잡 제어(Congestion control)&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;송신측의 데이터 전달과 네트워크의 처리속도 차이를 해결하기 위한 기법&lt;/strong&gt;이다.&lt;/p&gt;

        &lt;p&gt;송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.&lt;/p&gt;

        &lt;p&gt;하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다.&lt;/p&gt;

        &lt;p&gt;만약, 한 라우터에 데이터가 몰릴 경우, 다시 말해 혼잡할 경우 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.&lt;/p&gt;

        &lt;p&gt;그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.&lt;/p&gt;

        &lt;p&gt;따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이게 된다.&lt;/p&gt;

        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Slow start&lt;/p&gt;

            &lt;p&gt;윈도우 크기를 2배로 늘린다.&lt;/p&gt;

            &lt;p&gt;그러다 혼잡현상이 발생하면 창 크기를 1로 떨어뜨린다.&lt;/p&gt;

            &lt;p&gt;그 후 혼잡현상이 발생했던 창 크기의 절반까지는 이전처럼 지수 함수 꼴로(2배로) 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Fast Recovery&lt;/p&gt;

            &lt;p&gt;혼잡한 상태가 되면 창 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/271490475897F87C37&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;출처: &lt;a href=&quot;https://jsonsang2.tistory.com/17&quot;&gt;https://jsonsang2.tistory.com/17&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;l2-인터넷-계층internet-layer&quot;&gt;L2 인터넷 계층(Internet Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: 패킷
&lt;strong&gt;전송 주소&lt;/strong&gt;: IP&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공&lt;/li&gt;
  &lt;li&gt;단말을 구분하기위해 논리적인 주소(Logical Address) IP를 할당
    &lt;ul&gt;
      &lt;li&gt;출발지와 목적지의 논리적 주소가 담겨있는 IP datagram이라는 패킷으로 데이타를 변경&lt;/li&gt;
      &lt;li&gt;데이터 전송을 위한 주소 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라우팅(Routing) 기능을 처리
    &lt;ul&gt;
      &lt;li&gt;경로 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최종 목적지까지 정확하게 연결되도록 연경성 제공&lt;/li&gt;
  &lt;li&gt;패킷단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;세그먼트를 목적지까지 전송하기 위해 시작 주소와 목적지의 논리적 주소를 붙인 단위. 데이타 + IP Header&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-2&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;IP, ARP, ICMP, RARP, OSPF&lt;/p&gt;

&lt;h2 id=&quot;l1-네트워크-연결-계층network-access-layernetwork-interface-layer&quot;&gt;L1 네트워크 연결 계층(Network Access Layer/Network Interface Layer)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이타 단위&lt;/strong&gt;: 프레임
&lt;strong&gt;전송 주소&lt;/strong&gt;: MAC&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리적으로 데이타가 네트워크를 통해 어떻게 전송되는지를 정의
    &lt;ul&gt;
      &lt;li&gt;논리주소(IP주소 등)이 아닌 물리주소(예. MAC주소(Media Access Control Address))을 참조해 장비간 전송&lt;/li&gt;
      &lt;li&gt;MAC주소란 컴퓨터의 하드웨워 주소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적으로 에러검출/패킷의 프레임화 담당&lt;/li&gt;
  &lt;li&gt;프레임(Frame)단위의 데이타 구성
    &lt;ul&gt;
      &lt;li&gt;최종적으로 데이타 전송을 하기 전 패킷헤더에 MAC주소와 오류 검출을 위한 부분을 첨부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예시-3&quot;&gt;예시&lt;/h4&gt;

&lt;p&gt;MAC, LAN, 패킷망 등에 사용되는 것
예) Ethernet, PPP, Token Ring 등&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;출처: &lt;a href=&quot;https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층&quot;&gt;https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Network" /><category term="TCP/IP" /></entry><entry><title type="html">21년 1월 30일</title><link href="http://localhost:4000/til/2021/01/30/TIL25.html" rel="alternate" type="text/html" title="21년 1월 30일" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/30/TIL25</id><content type="html" xml:base="http://localhost:4000/til/2021/01/30/TIL25.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 셔틀버스 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;셔틀버스&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;탑승을 위해 고려하는 timetable의 최대 개수가 2000이기 때문에, 구현자체가 중요하다고 생각했다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;간단한 구현이었다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;timetable을 시간순서로 정렬한다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;주어진 간격대로 셔틀버스를 출발시키고, 탈 수 있는 승객을 태운다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;마지막 셔틀버스를 출발시킬 때&lt;/p&gt;

                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;p&gt;정원이 꽉차지 않았다면 마지막 셔틀버스출발시간에 줄을 서야한다.&lt;/p&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;p&gt;정원이 꽉찼다면 마지막 승객보다 1분 빨리 줄을 서야한다.&lt;/p&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;계획한 걸 제대로 못하고 있다. 알고리즘만 한문제 겨우 풀었다.&lt;/li&gt;
  &lt;li&gt;개인 멘탈 문제이다. 안좋은 일이 많은 한 주였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;요즘 집중이 흐트러진다.&lt;/li&gt;
  &lt;li&gt;개발 자체는 재밌지만, 블로그 글을 쓰는 것에 대한 부담?때문에 공부를 회피하는것 같다.&lt;/li&gt;
  &lt;li&gt;글을 잘 쓰려고 부담을 갖지말아야겠다 ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;쉬기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Load Data (bulk insert) 시도 secure_file_priv 문제 뜰 때</title><link href="http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err.html" rel="alternate" type="text/html" title="Load Data (bulk insert) 시도 secure_file_priv 문제 뜰 때" /><published>2021-01-29T00:00:00+09:00</published><updated>2021-01-29T00:00:00+09:00</updated><id>http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err</id><content type="html" xml:base="http://localhost:4000/mysql/2021/01/29/mysql_secure_file_priv_err.html">&lt;h2 id=&quot;mysql-에서-bulk-insert-명령을-실행할-때-secure_file_priv-에러-발생&quot;&gt;Mysql 에서 bulk insert 명령을 실행할 때, secure_file_priv 에러 발생&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;쉘스크립트에서 아래와 같이 특정 파일을 bulk insert시도 하였고 secure_file_priv에러 발생하였다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;test.sh&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
  
mysql &lt;span class=&quot;nt&quot;&gt;-uroot&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;패스워드 db명 &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
  
LOAD DATA INFILE 'test.txt'
INTO TABLE user_log
FIELDS TERMINATED BY ',';
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR 1290 (HY000) at line 2: The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결방법&quot;&gt;해결방법&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mysql에 접속하여 변수 상태를 확인한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SELECT @@GLOBAL.secure_file_priv;
+---------------------------+
| @@GLOBAL.secure_file_priv |
+---------------------------+
| /var/lib/mysql-files/     |
+---------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 secure_file_priv에 설정된 경로에 파일이 위치해야만 bulk insert가 가능하다고 한다.&lt;/p&gt;

&lt;p&gt;다만, mysql 설정 파일에 아래 내용을 추가한 후 mysql을 재시작하면 아무 위치에서나 bulk insert가 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[mysqld]
secure-file-priv=&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="Mysql" /></entry><entry><title type="html">Docker mysql 이미지 실행 및 한글설정</title><link href="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html" rel="alternate" type="text/html" title="Docker mysql 이미지 실행 및 한글설정" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config</id><content type="html" xml:base="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html">&lt;h3 id=&quot;docker-docs를-참고하여-진행했습니다&quot;&gt;Docker Docs를 참고하여 진행했습니다.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;Docker Docs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql-이미지를-컨테이너로-실행하고-설정한-기록&quot;&gt;mysql 이미지를 컨테이너로 실행하고 설정한 기록&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;docker hub 에서 mysql image pull 받기&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;image를 container로 실행하기(-d는 background로 실행, -e는 환경변수 설정한다는 뜻)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ROOT_PWD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;비밀번호 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너에게 exec명령어로 bash 실행하기 (-i는 Keep STDIN open even if not attached라는 뜻, -t 는 psedo TTY를 할당한다)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docer &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; mysql /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;locale 설정하기 (Debian Linux 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update
apt upgrade
apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; locales locales-all
dpkg-reconfigure locales &lt;span class=&quot;c&quot;&gt;#여기서 실행되는 프로그램에서 ko_KR.UTF-8을 선택&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;4-1) 현재 컨테이너를 이미지로 만든 후 LC_ALL 환경변수를 ko_KR.UTF-8로 변경하여 재실행한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker commit mysql isaac/mysql
docker container &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;mysql
docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;LC_ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ko_KR.UTF-8 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; isaac/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql -uroot -p비밀번호 명령어를 통해 mysql 접속한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uroot -p루트비번
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;status 명령어로 현재 설정 확인하면 characterset이 latin1로 되어있는 걸 확인할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; status
--------------
mysql  Ver 14.14 Distrib 5.7.33, for Linux (x86_64) using  EditLine wrapper
   
Connection id:		3
Current database:	
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.7.33 MySQL Community Server (GPL)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	latin1
Db     characterset:	latin1
Client characterset:	latin1
Conn.  characterset:	latin1
UNIX socket:		/var/run/mysqld/mysqld.sock
Uptime:			49 min 29 sec
   
Threads: 1  Questions: 7  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.002
--------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/mysql/mysql.conf.d/mysqld.cnf 파일을 수정해준다. (도커허브 mysql:5.7 이미지 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//아래 내용을 파일에 추가해준다.
[client]
default-character-set=utf8
   
[mysql]
default-character-set=utf8
   
[mysqld]
collation-server = utf8_unicode_ci
init-connect='SET NAMES utf8'
character-set-server = utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docer container 명령어로 restart시켜준다&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker container restart mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Docker" /></entry><entry><title type="html">21년 1월 28일</title><link href="http://localhost:4000/til/2021/01/28/TIL24.html" rel="alternate" type="text/html" title="21년 1월 28일" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/28/TIL24</id><content type="html" xml:base="http://localhost:4000/til/2021/01/28/TIL24.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;오랜만에 도커를 사용하여 mysql을 실행하고 locale 설정까지 해보았다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;도커허브의 mysql:5.7 이미지를 이용하여 실행했다.&lt;/li&gt;
      &lt;li&gt;해당 이미지는 debian linux를 토대로 mysql이 설치되어 있었다.&lt;/li&gt;
      &lt;li&gt;debian에서 locale설정하는 법을 알게 되었다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;쉘 스크립트를 이용해 file을 작성하고 file을 bulk insert하여 100만개의 랜덤데이터를 생성했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/docker/2021/01/28/Docker_mysql_image_run_config.html&quot;&gt;환경설정한 기록&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;전날 늦게 잔 후유증으로 집중이 잘안되서 일찍 자버렸다.&lt;/li&gt;
  &lt;li&gt;코드스쿼드 미션 이외에 개인공부를 하지 못했다(알고리즘, 자바의정석 읽기 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자주 사용하지 못해서 docker docs를 확인하며 명령을 실행했고 익숙해져서 기분이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Docker" /><category term="Algorithm" /></entry></feed>