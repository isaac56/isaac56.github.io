<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-29T16:39:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dev.Isaac</title><subtitle>정이삭 공부블로그</subtitle><entry><title type="html">21년 1월 28일</title><link href="http://localhost:4000/til/2021/01/28/TIL24.html" rel="alternate" type="text/html" title="21년 1월 28일" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/28/TIL24</id><content type="html" xml:base="http://localhost:4000/til/2021/01/28/TIL24.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 docker로 mysql을 실행하고 locale 설정하는 과정을 진행했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;도커허브의 mysql:5.7 이미지를 이용하여 실행했다.&lt;/li&gt;
      &lt;li&gt;해당 이미지는 debian linux를 토대로 mysql이 설치되어 있었다.&lt;/li&gt;
      &lt;li&gt;debian에서 locale설정하는 법을 알게 되었다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;쉘 스크립트를 이용해 file을 작성하고 file을 bulk insert하여 100만개의 랜덤데이터를 생성했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/docker/2021/01/28/Docker_mysql_image_run_config.html&quot;&gt;환경설정한 기록&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;전날 늦게 잔 후유증으로 집중이 잘안되서 일찍 자버렸다.&lt;/li&gt;
  &lt;li&gt;코드스쿼드 미션 이외에 개인공부를 하지 못했다(알고리즘, 자바의정석 읽기 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ㅠㅠ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;회사에서 종종 사용하던 docker를 이용한 미션이 나와서 반가웠다.&lt;/li&gt;
  &lt;li&gt;자주 사용하지 못해서 docker docs를 확인하며 명령을 실행했고 익숙해져서 기분이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Docker" /><category term="Algorithm" /></entry><entry><title type="html">Docker mysql 이미지 실행 및 한글설정</title><link href="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html" rel="alternate" type="text/html" title="Docker mysql 이미지 실행 및 한글설정" /><published>2021-01-28T00:00:00+09:00</published><updated>2021-01-28T00:00:00+09:00</updated><id>http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config</id><content type="html" xml:base="http://localhost:4000/docker/2021/01/28/Docker_mysql_image_run_config.html">&lt;h3 id=&quot;docker-docs를-참고하여-진행했습니다&quot;&gt;Docker Docs를 참고하여 진행했습니다.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;Docker Docs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql-이미지를-컨테이너로-실행하고-설정한-기록&quot;&gt;mysql 이미지를 컨테이너로 실행하고 설정한 기록&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;docker hub 에서 mysql image pull 받기&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;image를 container로 실행하기(-d는 background로 실행, -e는 환경변수 설정한다는 뜻)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;MYSQL_ROOT_PWD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;비밀번호 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; mysql:5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너에게 exec명령어로 bash 실행하기 (-i는 Keep STDIN open even if not attached라는 뜻, -t 는 psedo TTY를 할당한다)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docer &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; mysql /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;locale 설정하기 (Debian Linux 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update
apt upgrade
apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; locales locales-all
dpkg-reconfigure locales &lt;span class=&quot;c&quot;&gt;#여기서 실행되는 프로그램에서 ko_KR.UTF-8을 선택&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;4-1) 현재 컨테이너를 이미지로 만든 후 LC_ALL 환경변수를 ko_KR.UTF-8로 변경하여 재실행한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker commit mysql isaac/mysql
docker container &lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;mysql
docker run &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;LC_ALL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ko_KR.UTF-8 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; isaac/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql -uroot -p비밀번호 명령어를 통해 mysql 접속한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uroot -p루트비번
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;status 명령어로 현재 설정 확인하면 characterset이 latin1로 되어있는 걸 확인할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; status
--------------
mysql  Ver 14.14 Distrib 5.7.33, for Linux (x86_64) using  EditLine wrapper
   
Connection id:		3
Current database:	
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.7.33 MySQL Community Server (GPL)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	latin1
Db     characterset:	latin1
Client characterset:	latin1
Conn.  characterset:	latin1
UNIX socket:		/var/run/mysqld/mysqld.sock
Uptime:			49 min 29 sec
   
Threads: 1  Questions: 7  Slow queries: 0  Opens: 105  Flush tables: 1  Open tables: 98  Queries per second avg: 0.002
--------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/mysql/mysql.conf.d/mysqld.cnf 파일을 수정해준다. (도커허브 mysql:5.7 이미지 기준입니다.)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//아래 내용을 파일에 추가해준다.
[client]
default-character-set=utf8
   
[mysql]
default-character-set=utf8
   
[mysqld]
collation-server = utf8_unicode_ci
init-connect='SET NAMES utf8'
character-set-server = utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;docer container 명령어로 restart시켜준다&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker container restart mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="Docker" /></entry><entry><title type="html">21년 1월 27일</title><link href="http://localhost:4000/til/2021/01/27/TIL23.html" rel="alternate" type="text/html" title="21년 1월 27일" /><published>2021-01-27T00:00:00+09:00</published><updated>2021-01-27T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/27/TIL23</id><content type="html" xml:base="http://localhost:4000/til/2021/01/27/TIL23.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 비동기 프로그래밍 미션을 하루종일 했다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;미션에서 주어진 역할을 클래스로 만들고 객체간의 메세지를 보내(메소드 실행) 이벤트를 발생하게 했다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;객체 각자가 비동기적으로 일을 수행해, 주문을 받은 커피를 만들고 커피가 완료됐다고 출력하는 미션이었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;만든 클래스는 다음과 같다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;주문을 받는 Cashier Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문 목록을 갖고있는 OrderList Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;OrderList를 보고 일을 할당해주는 Manager Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피를 만드는 Barista Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;완료된 목록을 출력해주는 DashBoard Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류인 CoffeeType Enum&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;커피 종류와 주문한 고객정보를 갖고있는 Coffee Class&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;주문한 고객정보와 Coffee를 모두 담고 있는 Order Class&lt;/p&gt;

            &lt;p&gt;(고객1이 아메리카노2잔,카페라떼3잔을 시켰다면 커피1잔은 Coffee Class에 해당하고, 전체 주문 한건은 Order Class에 해당)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture에서 제공하는 runAsync나 supplyAsync를 사용하면 Executors로 직접 쓰레드풀을 생성할 필요가 없이,&lt;/p&gt;

        &lt;p&gt;ForkJoinPool에서 제공하는 쓰레드 풀에 Task를 할당할 수 있다. (매우 편리하다!)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CompleteFuture를 사용하면 콜백지옥없이 thenApplyAsync와 같은 메소드를 통해, promise패턴으로 구현이 가능하다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;모든 주문이 완료된 상태에서 3초간 input이 들어오지 않으면 종료시킨다는 조건이 있었는데, io 블락중인 상태를 어떻게 종료해야할지 몰라서 정말 힘들었다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;io입력 받는 부분을 CompletFuture를 통해 non-block 상태로 실행시킨다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;future.getNow(null) 메소드를 통해 (task가 완료되면 리턴값을, 아직 진행중이면 null을 반환한다는 의미)&lt;/p&gt;

            &lt;p&gt;io로 input이 들어왔는지 판단한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;io로 input이 들어오지 않은 상태에서 모든 주문이 끝났고, 주문이 끝난지 3초 이상 지났으면 함수를 return해준다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;데몬 쓰레드에서 돌고있는 Scanner.nextLine()이 종료되지 않은 상태에서 메인 쓰레드가 종료되기 때문에, 프로세스가 종료된다.&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showMenu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//메뉴 목록 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;showHowToOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문하는 방법 출력&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문받기 시작했기 때문에, 주문이 완료된적 없음&lt;/span&gt;
       
        &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CompletableFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;supplyAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//listen값이 null이 아닌동안 계속 확인&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{};&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//주문완료, 3초 지났으면 종료&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;모든 메뉴가 완성되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;orderCompleted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Order&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;translateOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orderString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;올바른 형식을 입력해주세요.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;orderList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;미션이 생각보다 어려워서, 알고리즘 공부와 자바의정석 읽기를 못했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;생각보다 어려웠는데 새벽 3시까지 코딩해서 결국 다 만들었다 ㅎㅎ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;힘든 일이 있어서 멘붕이 왔었는데, 다시 회복하고 있다.&lt;/li&gt;
  &lt;li&gt;깨졌던 공부 루틴을 회복하기 시작해서 좋다.&lt;/li&gt;
  &lt;li&gt;CompleteFuture를 사용하니까 너무 편리하다. (내부 작동원리 등은 계속 써가면서 공부해야 할 것 같다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 26일</title><link href="http://localhost:4000/til/2021/01/26/TIL22.html" rel="alternate" type="text/html" title="21년 1월 26일" /><published>2021-01-26T00:00:00+09:00</published><updated>2021-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/26/TIL22</id><content type="html" xml:base="http://localhost:4000/til/2021/01/26/TIL22.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 단어변환 문제를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;단어변환:
        &lt;ol&gt;
          &lt;li&gt;간단한 BFS문제이다.&lt;/li&gt;
          &lt;li&gt;문제에서 주어진 규칙만 준수하여, visit체크와 함께 변환한 단어를 queue에 넣어준다.&lt;/li&gt;
          &lt;li&gt;queue에서 꺼낸 값이 target과 일치할 경우 변환한 개수를 반환하면 된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 처음으로 TIL도 쓰지 않고, 아무것도 하지 못했다.&lt;/li&gt;
  &lt;li&gt;오늘도 코드스쿼드 미션은 읽어보지도 못하고 울면서 알고리즘 한문제만 겨우 푼거같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어제 오늘 개인사정으로 인해 정말 오르락내리락 멘탈이 무너졌던 이틀이었다.&lt;/li&gt;
  &lt;li&gt;무슨일이 생겨도 꾸준히 하던 것을 놓으면 안되는데, 애초에 멘탈을 강하게 지켜야하는데 이번 일은 그게 좀 힘들었다.&lt;/li&gt;
  &lt;li&gt;내일부터 다시 제대로 열심히 꾸준히 해보려고한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking</title><link href="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html" rel="alternate" type="text/html" title="Synchronous vs Asynchrnonous와 Blocking vs Non-Bolocking" /><published>2021-01-25T00:00:00+09:00</published><updated>2021-01-25T00:00:00+09:00</updated><id>http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking</id><content type="html" xml:base="http://localhost:4000/java/2021/01/25/Sync_Async_Blocking_NonBlocking.html">&lt;h2 id=&quot;synchronous--asynchronous&quot;&gt;Synchronous / Asynchronous&lt;/h2&gt;

&lt;p&gt;Synchronous의 어원부터 살펴보면, Sync (함께) + Chrono(시간) 이 합쳐진 단어이다.&lt;/p&gt;

&lt;p&gt;즉, Synchronous란 ‘함께 시간을 맞춰 행동한다’고 해석할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, B라는 function을 사용하는 A라는 function이 있다고 해보자&lt;/p&gt;

&lt;p&gt;여기서 A는 호출한 자라고 할 수 있고, B는 호출받은 자라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;synchronous&quot;&gt;Synchronous&lt;/h3&gt;

&lt;p&gt;A는 B를 호출하게 되고, B가 종료되는 시점에 A가 그 다음 동작을 수행한다면 Synchronous라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하면 Synchronous인 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 시간을 맞춰 행동하면 코드의 작성 순서대로 실행된다는 것을 보장할 수 있게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 시작되었습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A가 끝났습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B입니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바는 기본적으로 Blocking / Synchronous한 언어이기 때문에, A() 메소드를 실행한다면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A가 시작되었습니다.&lt;/li&gt;
  &lt;li&gt;B입니다.&lt;/li&gt;
  &lt;li&gt;A가 끝났습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;순서로 출력이 될 것이다.&lt;/p&gt;

&lt;p&gt;Synchronous하기 때문에, B의 호출이 끝나는 시간과 A가 시작되는 시간이 일치하기 때문이다.&lt;/p&gt;

&lt;p&gt;다시 말하면, B의 호출이 끝난 후(“B입니다.” 출력) A가 다시 시작하여 (“A가 끝났습니다.”)를 출력하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;asynchrnous&quot;&gt;Asynchrnous&lt;/h3&gt;

&lt;p&gt;Asynchronous는 Synchronous에 반대를 뜻하는 접두사 A가 붙은 형태이다.&lt;/p&gt;

&lt;p&gt;즉, 시간을 맞추지 않는다고 생각하면 될 것이다.&lt;/p&gt;

&lt;p&gt;A가 B를 호출한 뒤, B의 종료여부를 신경쓰지 않고 다시 A가 작업을 재개하는 것을 생각하면된다.&lt;/p&gt;

&lt;p&gt;호출된 자의 종료 시간과 호출한 자의 시작 시간이 일치하지 않는 것이다.&lt;/p&gt;

&lt;p&gt;위의 예가 Asynchronous하게 동작한다면,&lt;/p&gt;

&lt;p&gt;A는 B를 호출한 후 B의 종료 시점을 기다리지 않고, “A가 끝났습니다.”를 출력하려고 할 것이다.&lt;/p&gt;

&lt;p&gt;따라서, “B입니다.”가 먼저 출력될지 “A가 끝났습니다.”가 먼저 출력될지 알 수 없게 된다.&lt;/p&gt;

&lt;p&gt;코드의 작성 순서대로 실행되는 것이 보장되지 않는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;blocking--non-blocking&quot;&gt;Blocking / Non-Blocking&lt;/h2&gt;

&lt;p&gt;Blocking과 Non-Blocking을 설명하기 위해서 제어권이라는 용어가 많이 사용된다.&lt;/p&gt;

&lt;p&gt;간단하게, 제어권이란 스스로 동작할 수 있는 권리라고 이해하면 된다.&lt;/p&gt;

&lt;p&gt;A라는 함수에 제어권이 있다면 A는 현재 동작할 수 있는 상태인 것이다.&lt;/p&gt;

&lt;p&gt;Blocking / Non-Blocking은 이런 제어권의 반환이 언제 되느냐에 대한 관점이다.&lt;/p&gt;

&lt;h3 id=&quot;blocking&quot;&gt;Blocking&lt;/h3&gt;

&lt;p&gt;Blocking은 호출된 함수가 종료될 때까지 호출한 자에게 제어권을 넘겨주지 않는 것이다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;non-blocking&quot;&gt;Non-Blocking&lt;/h3&gt;

&lt;p&gt;Non-Blocking에서 호출된 함수는 제어권을 바로 호출한 함수에게 넘겨준다.&lt;/p&gt;

&lt;p&gt;즉, 호출된 함수가 종료될 때까지 호출한 함수의 동작을 Block하지 않는다.&lt;/p&gt;

&lt;p&gt;Non-Blocking 함수를 호출한다면, 호출자에게 제어권을 바로 반환하기 때문에,&lt;/p&gt;

&lt;p&gt;호출자는 자신의 동작을 진행할 수 있고, 호출된 함수도 자신의 동작을 진행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참고하기 매우 좋은 글&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&quot;&gt;https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Synchronous" /><category term="Asynchronous" /><category term="Blocking" /><category term="Non-Bolocking" /></entry><entry><title type="html">21년 1월 24일</title><link href="http://localhost:4000/til/2021/01/24/TIL21.html" rel="alternate" type="text/html" title="21년 1월 24일" /><published>2021-01-24T00:00:00+09:00</published><updated>2021-01-24T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/24/TIL21</id><content type="html" xml:base="http://localhost:4000/til/2021/01/24/TIL21.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 12 지네릭스, 열거형, 애너테이션 중 지네릭스를 모두 읽었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭스는 클래스 또는 메소드에 타입을 파라미터처럼 전달하여(타입 변수) 타입을 보다 자유롭게 쓸 수 있게 해준다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭스의 장점은 다음과 같다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;타입 안정성을 제공한다.&lt;/li&gt;
          &lt;li&gt;타입체크와 형변환을 생략할 수 있어 코드를 간소화해준다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭 메소드에 선언된 타입 변수와 지네릭 클래스에 선언된 타입 변수는 다르다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;지네릭 메소드에 선언된 타입 변수는 해당 메소드의 지역 변수와 같은 우선순위를 갖는다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;즉, 지네릭 클레스에 T라는 타입변수가 선언되어 있고, 지네릭 메소드에 T라는 타입변수가 있으면,&lt;/p&gt;

            &lt;p&gt;해당 메소드 내의 T는 지역변수나 마찬가지인 지네릭 메소드의 T를 의미한다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;와일드 카드에 대해 배웠다.&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드는 ?로 정의되며 &amp;lt;?&amp;gt; 라는 건 &amp;lt;? extends Object&amp;gt;를 생략한 것이다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드는 참조변수 타입에 선언되는데,&lt;/p&gt;

            &lt;p&gt;&amp;lt;? extends Fruit&amp;gt;라면 해당 참조변수의 인스턴스에는 타입 변수로 Fruit와 Fruit를 상속한 클래스 타입이 들어갈 수 있고,&lt;/p&gt;

            &lt;p&gt;&amp;lt;? super Fruit&amp;gt;일 경우에는 타입 변수로 Fruit와 Fruit가 상속한 부모 클래스 타입이 들어갈 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;와일드 카드로 선언된 참조변수 간에는 컴파일러가 판단하여 형변환을 할 수 있게 해준다.&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;Fruit와 Fruit를 상속 받은 Apple, Grape가 있다고 하자.&lt;/p&gt;

                &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 에러;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 에러; &lt;/span&gt;
         
&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//경고; fruitList는 Apple로 형변환할 수 있는 타입이 들어갈수도 있으므로 에러로 막지는 않음&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fruitList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//성공; appleList는 Fruit로 형변환할 수 있는 타입이 들어가있으므로 경고하지 않음&lt;/span&gt;
         
&lt;span class=&quot;c1&quot;&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
         
&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Apple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//에러; grapeList는 Apple로 형변환할 수 있는 타입이 들어갈 수 없으므로 에러&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;grapeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appleList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//에러; appleList는 grape로 형변환할 수 있는 타입이 들어갈 수 없으므로 에러&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 타겟넘버, 네트워크 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;타겟넘버:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;간단한 DFS/BFS문제이다.&lt;/li&gt;
          &lt;li&gt;주어진 숫자들을 +또는 -로 연산해가면서 마지막에 target과 같을 경우 경우의 수를 늘려준다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;네트워크:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;DFS/BFS로 풀수도 있고, union-find알고리즘으로 풀 수도 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;두 가지 방법으로 모두 풀어봤다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;union-find의 경우는 computers매개변수를 순회하며 1인경우 두 노드를 하나의 집합으로 만들어준다.&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;
                &lt;p&gt;마지막에 parent 배열을 순회하며 각 parent배열 값을 다시 getParent(parent[n])로 확인하여 HashSet(집합 명 Set)에 넣어준다.&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;HashSet의 size가 네트워크 개수가 된다.&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DFS/BFS로 푸는 방법은 그냥 areaNum을 늘려주며 area가 정해지지 않은 node의 area를 DFS/BFS로 areaNum으로 정해준다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기라는 목표를 점점 뒤로 미루고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주말이라 쉬엄쉬엄했지만 꾸준함의 중요성을 인지하며 공부하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;제너릭스는 생각보다 어렵지 않았다.&lt;/li&gt;
  &lt;li&gt;자바 API를 읽을때마다 헷갈렸던 ?라는 와일드카드를 알게되어서 기분이 좋았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션 하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;자바의 정석 열거형 읽기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더 쉽게는 자바의 정석 1회독 한 후 읽어야 할 것 같다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 23일</title><link href="http://localhost:4000/til/2021/01/23/TIL20.html" rel="alternate" type="text/html" title="21년 1월 23일" /><published>2021-01-23T00:00:00+09:00</published><updated>2021-01-23T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/23/TIL20</id><content type="html" xml:base="http://localhost:4000/til/2021/01/23/TIL20.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 13 쓰레드 (9.쓰레드의 동기화 ~ 끝) 모두 읽었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;synchronized를 이용한 동기화를 배웠다.
        &lt;ul&gt;
          &lt;li&gt;synchornized method와 synchronized block을 이용한 critical section 생성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특정 객체가 Lock을 너무 오래 갖는 것을 방지하기 위한 wait와 notify의 사용법을 배웠다.&lt;/li&gt;
      &lt;li&gt;JDK1.5부터 추가된 java.util.concurrent.locks 패키지 사용법을 배웠다.
        &lt;ul&gt;
          &lt;li&gt;ReetrantLock, ReetrantReadWriteLock, StampedLock 사용법&lt;/li&gt;
          &lt;li&gt;StampedLock은 ReetrantReadWriteLock에 optimisticLock이 추가된 Lock이다.
            &lt;ul&gt;
              &lt;li&gt;optimisticReadLock은 사용하면 바로 lock을 얻지만, 누군가 쓰기 lock을 얻는다면 바로 무효화된다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;await(), signal()은 synchronized의 wait(), notify()와 대응된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;volatile 키워드가 무엇인지 알게 되었다.
        &lt;ul&gt;
          &lt;li&gt;변수를 원자화한다.
            &lt;ol&gt;
              &lt;li&gt;JVM은 4바이트 단위로 처리하기 때문에, long이나 double 타입은 한번에 읽을수 없다.&lt;/li&gt;
              &lt;li&gt;volatile키워드로 선언하면 long이나 double도 다른 쓰레드의 침범 없이 원자화하여 읽을 수 있다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;항상 메모리에서 값을 가져온다.
            &lt;ol&gt;
              &lt;li&gt;멀티 코어에서는 각 코어가 캐시에 저장된 변수를 참조할 수도 있다.&lt;/li&gt;
              &lt;li&gt;즉, 1번 코어에서 메모리에 변수를 바꿔도, 2번 코어는 캐시의 변수를 참조하고 있으면 정상 동작하지 않는다.&lt;/li&gt;
              &lt;li&gt;이를 방지하기 위해서 volatile 키워드로 변수를 선언하여 항상 메모리에서 값을 읽도록 강제해준다.&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 정수삼각형, 등굣길을 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;정수삼각형:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;dp 문제 같긴한데, 그냥 iterative하게 푸는게 더 편하고 빠르다.&lt;/li&gt;
          &lt;li&gt;삼각형의 위층부터 내려오며 각 위치까지 오는데 가장 큰 값들을 계산해서 넣어준다.&lt;/li&gt;
          &lt;li&gt;삼각형의 맨 마지막 층에 각 위치별로 오는데 가장 큰 값이 저장되어 있을 것이다.&lt;/li&gt;
          &lt;li&gt;마지막 층에 저장된 값중 가장 큰 값을 반환한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;등굣길:&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;전형적인 dp문제이다.&lt;/li&gt;
          &lt;li&gt;(x,y)의 길의 개수는 (x-1,y)+(x,y-1)가 된다.&lt;/li&gt;
          &lt;li&gt;m,n 크기일 때, cache배열을 3차원 &lt;code class=&quot;highlighter-rouge&quot;&gt;new int[m][n][2]&lt;/code&gt; 으로 하는 것이 핵심이다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache[x][y][0]&lt;/code&gt; 에는 (x,y)값이 계산이 끝났는지(1), 물 웅덩이인지(-1), 아직 계산이 안됐는지(0)가 저장된다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache[x][y][1]&lt;/code&gt; 에는(x,y)값의 계산이 끝났을 경우 (x,y)값이 저장된다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;등굣길 문제를 풀 때, input으로 들어온 x,y좌표 기준과 내가 정의한 x,y좌표 기준이 틀려서 해멨다.
    &lt;ul&gt;
      &lt;li&gt;문제에서 (1,1)은 내가 설계한 코드에서는 (0,0)을 의미하기 때문에 x,y모두 1씩 빼줘야했다 ㅠㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 문제였으면 테스트케이스까지만 확인하고 냈으므로 틀렸을 것이다.&lt;/li&gt;
  &lt;li&gt;아주 사소한 문제인데, 또 실수를 해버려서 아쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석을 계획한 데로 읽었다.&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 2문제나 풀었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석 쓰레드는 운영체제 지식이 없으면 읽기 어려웠을 것 같다.&lt;/li&gt;
  &lt;li&gt;그래도 이해하면서 쓰레드 챕터를 완독할 수 있어서 아주 뿌듯했다.&lt;/li&gt;
  &lt;li&gt;다 외우는게 목적이 아니기 때문에, 이해만으로 넘어가고 앞으로 코딩할때 참고용으로 자주 봐야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
  &lt;li&gt;자바의 정석 제너릭스 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">21년 1월 22일</title><link href="http://localhost:4000/til/2021/01/22/TIL19.html" rel="alternate" type="text/html" title="21년 1월 22일" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/22/TIL19</id><content type="html" xml:base="http://localhost:4000/til/2021/01/22/TIL19.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;코드스쿼드 미션으로 프로세스의 시뮬레이션을 설계 및 구현해보았다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;CPU class를 만들어서 그 CPU는 항상 자신에게 올라온 Process를 Run하는 역할만 맡겼다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CPU는 무한루프를 돌면서 자신의 Process의 run 메소드를 실행하는데, run 메소드는 Process 클래스를 반환해서&lt;/p&gt;

        &lt;p&gt;다음으로 돌릴 Process는 계속 변하게 설계하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Process class를 상속받는 UserProcess(유저모드), KernelProcess(커널모드)를 만들었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UserProcess는 public Process run() 메소드를 통해 실행되게 되는데, run 한 번에 1tick으로&lt;/p&gt;

        &lt;p&gt;Timer Interrupt가 걸린다고 가정하고 구현하였다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UserProcess의 run메소드 마지막에 항상 자신이 갖고있는 KernelProcess의 TrapNumber를&lt;/p&gt;

        &lt;p&gt;Timer interrupt로 지정해주고 자신의 KernelProcess를 반환하게 된다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CPU에서는 반환된 KernelProcess의 run을 실행하게 되어 커널 모드로 진입하고 TrapNumber가&lt;/p&gt;

        &lt;p&gt;Timer interrupt라면 scheduler를 실행하여 다음으로 실행할 UserProcess를 반환한다.&lt;/p&gt;

        &lt;p&gt;(사실은 다음 Process의 Kernel모드를 반환후 다음 Process의 커널에서 유저모드로 전환해야 하는데,&lt;/p&gt;

        &lt;p&gt;구현상 너무 어려워서 하지 않았다.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;자바의 정석 Chapter 13 쓰레드 - 8. 쓰레드의 실행제어까지 읽었다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;서로 관련된 Thread를 그룹으로 묶기 위한 ThreadGroup이 있고,&lt;/p&gt;

        &lt;p&gt;ThreadGroup이 생성될때 어떤 규칙으로 생성되는지 알게 되었다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;suspend(), stop(), resume() 등이 동기화, 교착상태 등에서 문제를 발생할 수 있어&lt;/p&gt;

        &lt;p&gt;deprecated 되었다는 것을 알게 되었고, 이를 대체하기 위한 설계 구조를 배웠다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;interrupt()와 yield()를 이용해 좀더 반응성이 좋은 Thread를 설계하는 법을 배웠다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래머스 문제 N으로 표현 문제를 풀었다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;N으로 표현:&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;dp문제였는데, dp라는 개념을 다 까먹어서 답 코드를 보고 복기하였다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;모든 경우의 수를 생각하기 때문에 언뜻 dfs, bfs랑 비슷해 보일 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;그러나 경우를 잘게 쪼개서 (n+2의 경우) = (n+1의 경우와 n의 경우의 조합)와 같이&lt;/p&gt;

            &lt;p&gt;점화식을 구해서 모든 경우의 수를 쉽게 구할 수 있다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;특히 한번 n의 경우를 구했으면 cache 구조체에 저장하여,&lt;/p&gt;

            &lt;p&gt;다음부터 n의 경우는 cache에서 바로 반환 있어야 시간초과가 나지 않을 것이다 (메모이제이션)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;N으로 최소 갯수만큼 써서, number를 만들어야 한다.&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;기본적으로 N을 x번 써서 만들 수 있는 number는 NNN..(x번)이 존재한다.(기본숫자)&lt;/p&gt;

            &lt;p&gt;(ex: 9를 3번 써서 만들 수 있는 number에는 999가 포함된다.)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;따라서 N을 x번 써서 만들 수 있는 숫자는 (기본숫자) + (1번 쓰는 경우와 N-1번 쓰는 경우의 조합) +&lt;/p&gt;

            &lt;p&gt;(2번 쓰는 경우와 N-2번 쓰는 경우의 조합) + … + (N-1번 쓰는 경우와 1번 쓰는 경우의 조합)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;금요일이라고 일찍 쉬지 않고, 자바의 정석 읽기 + 코테연습 모드 진행하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바의 정석을 제대로 읽기 시작했는데, 자바에서 쓰레드를 쓰는 좋은 팁이 있었다. 정말 좋은 책 같다.&lt;/li&gt;
  &lt;li&gt;dp를 애매하게 알고 있어서 찜찜했는데 드디어 복습을 시작했다.&lt;/li&gt;
  &lt;li&gt;꾸준히 하면 언젠가 늘겠지, dp도 쉽게 느껴지는 날이 오기를&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
  &lt;li&gt;자바의 정석 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry><entry><title type="html">싱글코어에서도 Thread를 늘리면 빨라질까?</title><link href="http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread.html" rel="alternate" type="text/html" title="싱글코어에서도 Thread를 늘리면 빨라질까?" /><published>2021-01-22T00:00:00+09:00</published><updated>2021-01-22T00:00:00+09:00</updated><id>http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread</id><content type="html" xml:base="http://localhost:4000/os/2021/01/22/Is_it_faster_to_increase_thread.html">&lt;h2 id=&quot;싱글코어-cpu-한-개라서-실질적으로-한번에-한-개만-실행할-수-있다고-가정&quot;&gt;싱글코어 CPU 한 개라서, 실질적으로 한번에 한 개만 실행할 수 있다고 가정&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;여기서 덧셈을 하는 300개의 쓰레드를 생성해 돌린다고 가정해보자.&lt;/li&gt;
  &lt;li&gt;커널 레벨 쓰레드라면, 나의 Task(프로세스, 쓰레드 등 스케줄링해야 하는 작업 단위)가 많아진다.&lt;/li&gt;
  &lt;li&gt;다른 프로세스도 돌아가고 있을 것이므로, 쓰레드를 늘린 프로세스(나)의 CPU 점유율이 높아져서 내 속도가 빨라진다.&lt;/li&gt;
  &lt;li&gt;즉, 다른 프로세스도 돌아가고 있고, 커널 레벨 쓰레드라면, 나의 CPU점유율이 높아져서 속도가 빨라진다.&lt;/li&gt;
  &lt;li&gt;물론, 쓰레드 너무 많이 만든다면 오버헤드가 더 커져서 느려지게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;요약:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;멀티 프로세스 환경에서 다른 프로세스가 돌아가고 있을 때, 커널 레벨 쓰레드를 늘린다면 프로세스 속도는 빨라진다.&lt;/p&gt;

        &lt;p&gt;(CPU 점유율이 높아지기 때문에)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로세스가 딱 하나만 돌아가고 있거나, 유저 레벨 쓰레드를 늘린다면 오버헤드 때문에 프로세스 속도는 느려진다.&lt;/p&gt;

        &lt;p&gt;(유저 레벨 쓰레드는 프로세스 내에서 쓰레드 스케줄링할 뿐, 운영체제는 프로세스 하나로 보기 때문에 점유율이 높아지지 않는다.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="OS" /><category term="Process" /><category term="Thread" /></entry><entry><title type="html">21년 1월 21일</title><link href="http://localhost:4000/til/2021/01/21/TIL18.html" rel="alternate" type="text/html" title="21년 1월 21일" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>http://localhost:4000/til/2021/01/21/TIL18</id><content type="html" xml:base="http://localhost:4000/til/2021/01/21/TIL18.html">&lt;h2 id=&quot;한-일&quot;&gt;한 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스와 스레드의 차이점에 대해 공부하였다.&lt;/li&gt;
  &lt;li&gt;프로세스는 메모리에 적재하여 실행가능한 상태의 작업 단위이다.
    &lt;ul&gt;
      &lt;li&gt;스레드는 프로세스에 할당된 메모리 자원을 이용하여 실행되는 프로세스 내의 독립 실행 흐름이다.&lt;/li&gt;
      &lt;li&gt;스레드 간의 Context Switch는 레지스터 값과 Stack Pointer만 변경하면 되기 때문에 Process의 Context switch보다 빠르다.&lt;/li&gt;
      &lt;li&gt;스레드는 Stack영역 이외의 공간을 공유하기 때문에, 스레드 간의 통신이 쉽다.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://isaac56.github.io/os/2021/01/21/Process_vs_Thread.html&quot;&gt;Process vs Thread&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OperatingSystem Three Easy Pieces 책을 80 page까지 읽었다.
    &lt;ul&gt;
      &lt;li&gt;운영체제의 주요 컨셉인 CPU 가상화, 메모리 가상화, 동시 실행, 영속성을 배웠다.&lt;/li&gt;
      &lt;li&gt;프로세스가 실행되는 과정을 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 모드로의 전환과 프로세스 간의 컨텍스트 스위치 과정에 대해 배웠다.&lt;/li&gt;
      &lt;li&gt;커널 권한과 이에 따른 시스템 콜, 트랩 핸들러에 대해 배웠다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 불량 사용자, 단속카메라를 풀었다.
    &lt;ol&gt;
      &lt;li&gt;불량 사용자:
        &lt;ul&gt;
          &lt;li&gt;처음에 쉽게 접근했다가 복잡하다는 것을 깨달았다.&lt;/li&gt;
          &lt;li&gt;DFS로 풀었는데, HashSet을 남발하여 다소 찜찜하다.&lt;/li&gt;
          &lt;li&gt;DFS안에 현재까지의 불량 사용자 목록을 HashSet으로 담는다.&lt;/li&gt;
          &lt;li&gt;모든 밴 리스트를 참고하여 HashSet을 완성했으면 HashSet의 HashSet에 추가하여 중복을 제거한다.&lt;/li&gt;
          &lt;li&gt;HashSet의 HashSet의 size()가 정답의 개수가 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단속카메라:
        &lt;ul&gt;
          &lt;li&gt;Greedy 문제였다.&lt;/li&gt;
          &lt;li&gt;구현은 매우 쉬운데 아이디어를 떠올리는게 정말 어려웠다.&lt;/li&gt;
          &lt;li&gt;각 Route의 end 지점을 기준으로 오름차순 정렬을 한다.&lt;/li&gt;
          &lt;li&gt;end 지점을 기준으로 오름차순 정렬했기 때문에, 자신이 설치해야 하는 최선의 경우는 자신의 end지점에 설치하는 것이다.&lt;/li&gt;
          &lt;li&gt;정렬한 Routes를 순회하다가, 마지막에 설치한 카메라가 자신의 범위 안에 없으면, 자신의 end 위치에 카메라를 설치한다.
            &lt;ul&gt;
              &lt;li&gt;마지막에 설치한 카메라가 자신의 범위 안에 없으면 자신은 카메라를 안지나치는 것이다.&lt;/li&gt;
              &lt;li&gt;그 이유는 end를 기준으로 오름차순 정렬했고 이것을 순회하며 카메라를 설치하기 때문이다.&lt;/li&gt;
              &lt;li&gt;마지막에 설치한 카메라는 항상 설치된 카메라 중 제일 뒤쪽에 있는 카메라이다.&lt;/li&gt;
              &lt;li&gt;따라서 앞에 설치한 카메라가 자신의 범위 안에 있는데, 마지막 설치한 카메라가 자신의 범위 안에 없을 경우는 없다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘못한-것&quot;&gt;잘못한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;잘한-것&quot;&gt;잘한 것&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;OS를 오랜만에 복습하고, 글로 정리하여 포스팅하였다.&lt;/li&gt;
  &lt;li&gt;레벨 3 카카오 문제를 한번에 풀었다 (80분 걸림)&lt;/li&gt;
  &lt;li&gt;greedy문제를 끈질기게 생각해서 해결방법을 알아냈다 (50분 걸림)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;느낌&quot;&gt;느낌&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;오랜만에 OS를 복습했는데, 생각보다 까먹은게 많아서 아쉬웠다.(3학년때 정말 열심히 했는데 ㅠㅠ)&lt;/li&gt;
  &lt;li&gt;그래도 빠르게 읽고 다시 기억할 수 있어서 공부하길 잘했다는 생각이 든다.&lt;/li&gt;
  &lt;li&gt;카카오 문제 풀긴 했는데 HashSet의 HashSet을 쓴게 찜찜하여 다른 사람은 어떻게 풀었는지 참고해야겠다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;할-일&quot;&gt;할 일&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드스쿼드 미션하기&lt;/li&gt;
  &lt;li&gt;프로그래머스 문제 풀기&lt;/li&gt;
  &lt;li&gt;TCP/IP 쉽게 더쉽게 읽기&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Algorithm" /></entry></feed>