<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Dev.Isaac" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>Dev.Isaac</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/about/">Dev.Isaac</a>
	</div>
	<p class="lead">정이삭 공부블로그</p></div>

<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	        <li>
	        	<a class="nav-item" href="/about/">
	            	About
	            </a>
	        </li>
	      
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#TIL">
				<span class="name">TIL</span>
				<span class="badge">28</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Linux">
				<span class="name">Linux</span>
				<span class="badge">5</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Network">
				<span class="name">Network</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Java">
				<span class="name">Java</span>
				<span class="badge">6</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Data Structure">
				<span class="name">Data Structure</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Algorithm">
				<span class="name">Algorithm</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#OS">
				<span class="name">OS</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Docker">
				<span class="name">Docker</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Mysql">
				<span class="name">Mysql</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#gradle">
				<span class="name">gradle</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			TCP/IP 4계층
		</div>
		<time class="post-date dt-published" datetime="2021-02-01T00:00:00+09:00" itemprop="datePublished">2021/02/01
		</time>		
	</header>

	<div class="post-content">
		<h2 id="tcpip-4계층">TCP/IP 4계층</h2>

<blockquote>
  <p>계층모형
<br /></p>

  <p>계층모형은 컴퓨터들이 정보를 주고받는데 사용하는 프로토콜들을, 각 역할에 맞게 계층으로 나누어 분류한 집합이다.</p>

  <p>이렇게 역할에 따라 계층을 나눔으로써, 서로 간의 간섭을 최소화하고 사용의 편리성을 높인다.</p>

  <ul>
    <li>호환성 보장 (다른 제조사 장비들끼리도 통신 가능)으로 인한 비용 절감</li>
    <li>문제 발견이 쉬워짐 (어떤 계층에서 문제가 있는지 확인 가능)</li>
    <li>다른 계층의 전달 과정을 알 필요가 없어 해결해야할 문제가 단순해짐</li>
  </ul>
</blockquote>

<ul>
  <li>국제표준화기구 IOS(International Organization for Standardization)에서는 상호 이질적인 네트워크간의 연결에서 호환성의 결여를 막기위해 OSI(Open Systems Interconnection) 모형을 개발했다.</li>
  <li>실제 사용되는 TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형이다
    <ul>
      <li>네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준이 TCP/IP 4계층이다.</li>
    </ul>
  </li>
  <li>OSI 7계층을 4-5계층으로 분류하여 적용할 수 있다.</li>
</ul>

<h2 id="4계층-요약">4계층 요약</h2>

<table>
  <thead>
    <tr>
      <th>TCP/IP 4계층</th>
      <th>역할</th>
      <th>데이타 단위</th>
      <th>전송 주소</th>
      <th>예시</th>
      <th>장비</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>응용 계층(Application)</td>
      <td>응용프로그램 간의 데이타 송수신</td>
      <td>Data/Message</td>
      <td>-</td>
      <td>파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등</td>
      <td>-</td>
    </tr>
    <tr>
      <td>전송 계층(Transport)</td>
      <td>호스트 간의 자료 송수신</td>
      <td>Segment</td>
      <td>Port</td>
      <td>TCP, UDP, RTP, RTCP 등</td>
      <td>게이트웨이</td>
    </tr>
    <tr>
      <td>인터넷 계층(Internet)</td>
      <td>데이타 전송을 위한 논리적 주소 지정 및 경로 지정</td>
      <td>Packet</td>
      <td>IP</td>
      <td>IP, ARP, ICMP, RARP, OSPF</td>
      <td>라우터</td>
    </tr>
    <tr>
      <td>네트워크 연결 계층(Network Access)</td>
      <td>실제 데이타인 프레임을 송수신</td>
      <td>Frame</td>
      <td>MAC</td>
      <td>Ethernet, PPP, Token Ring 등</td>
      <td>브리지, 스위치</td>
    </tr>
  </tbody>
</table>

<h2 id="l4-응용-계층application-layer">L4 응용 계층(Application Layer)</h2>

<p><strong>데이타 단위</strong>: Data/Message</p>

<ul>
  <li>사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다</li>
  <li>응용프로그램(application)들이 데이터를 교환하기 위해 사용되는 프로토콜</li>
  <li>사용자 응용프로그램 인터페이스를 담당</li>
</ul>

<h4 id="예시">예시</h4>

<p>파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등</p>

<p><br /></p>

<h2 id="l3-전송-계층transport-layer">L3 전송 계층(Transport Layer)</h2>

<p><strong>데이타 단위</strong>: Segment
<strong>전송 주소</strong>: Port</p>

<ul>
  <li>통신 노드 간의 연결 제어 및 자료 송수신을 담당</li>
  <li>애플리케이션 계층의 세션과 데이터그램 통신서비스 제공</li>
  <li>세그먼트 (Segment)단위의 데이타 구성
    <ul>
      <li>실질적인 데이터 전송을 위해 데이타를 일정 크기로 나눈 것. 발신, 수신, 포트주소, 오류검출코드가 붙게된다</li>
    </ul>
  </li>
</ul>

<h4 id="예시-1">예시</h4>

<p>TCP, UDP, RTP, RTCP 등</p>

<p><br /></p>

<ul>
  <li>
    <p><strong>TCP의 혼잡 방지 알고리즘</strong></p>

    <ol>
      <li>
        <p>흐름 제어(Flow Control)</p>

        <p>송신측과 수신측의 데이터처리 속도 차이를 해결하기 위한 기법이다.</p>

        <p>수신측이 송신측보다 속도가 빠른것은 아무런 문제가 되지 않지만, <strong>송신측이 수신측보다 속도가 빠르면 문제가 발생한다.</strong></p>

        <p>수신측에서 수신된 데이터를 처리해서 윗 계층으로 서비스 하는 속도보다 송신측에서 보내는 데이터 속도가 더 빠르다면, 수신측에서 제한된 저장용량(일반적으로 큐)을 초과하여 이후에 도착하는 데이터의 손실을 가져올 수있다.</p>

        <p>그렇다면 불필요하게 응답과 재전송의 데이터가 다시 송신측과 수신측간에 비번히 이동해야한다.</p>

        <p>따라서, 이러한 위험을 줄이기 위해 <strong>강제로 송신측의 데이터 전송을 줄인다</strong>.</p>

        <p><br /></p>

        <ol>
          <li>
            <p>Stop and wait 방식</p>

            <p>매번 전송한 패킷에 대해 확인응답을 받아야만 그 다음 패킷을 전송하는 방법</p>
          </li>
        </ol>

        <p><br /></p>

        <ol>
          <li>
            <p>슬라이딩 윈도우 기법</p>

            <p>수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법이다.</p>

            <p>이 처럼 슬라이딩 윈도우 기법을 통하여 <strong>송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜</strong>으로써 흐름제어를 수행한다.</p>
          </li>
        </ol>

        <p><br /></p>
      </li>
      <li>
        <p>혼잡 제어(Congestion control)</p>

        <p><strong>송신측의 데이터 전달과 네트워크의 처리속도 차이를 해결하기 위한 기법</strong>이다.</p>

        <p>송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.</p>

        <p>하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다.</p>

        <p>만약, 한 라우터에 데이터가 몰릴 경우, 다시 말해 혼잡할 경우 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.</p>

        <p>그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.</p>

        <p>따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이게 된다.</p>

        <p><br /></p>

        <ol>
          <li>
            <p>Slow start</p>

            <p>윈도우 크기를 2배로 늘린다.</p>

            <p>그러다 혼잡현상이 발생하면 창 크기를 1로 떨어뜨린다.</p>

            <p>그 후 혼잡현상이 발생했던 창 크기의 절반까지는 이전처럼 지수 함수 꼴로(2배로) 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.</p>
          </li>
          <li>
            <p>Fast Recovery</p>

            <p>혼잡한 상태가 되면 창 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다.</p>
          </li>
        </ol>

        <p><img src="https://t1.daumcdn.net/cfile/tistory/271490475897F87C37" alt="img" /></p>
      </li>
    </ol>

    <p>출처: <a href="https://jsonsang2.tistory.com/17">https://jsonsang2.tistory.com/17</a></p>
  </li>
</ul>

<p><br /></p>

<h2 id="l2-인터넷-계층internet-layer">L2 인터넷 계층(Internet Layer)</h2>

<p><strong>데이타 단위</strong>: 패킷
<strong>전송 주소</strong>: IP</p>

<ul>
  <li>네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공</li>
  <li>단말을 구분하기위해 논리적인 주소(Logical Address) IP를 할당
    <ul>
      <li>출발지와 목적지의 논리적 주소가 담겨있는 IP datagram이라는 패킷으로 데이타를 변경</li>
      <li>데이터 전송을 위한 주소 지정</li>
    </ul>
  </li>
  <li>라우팅(Routing) 기능을 처리
    <ul>
      <li>경로 설정</li>
    </ul>
  </li>
  <li>최종 목적지까지 정확하게 연결되도록 연경성 제공</li>
  <li>패킷단위의 데이타 구성
    <ul>
      <li>세그먼트를 목적지까지 전송하기 위해 시작 주소와 목적지의 논리적 주소를 붙인 단위. 데이타 + IP Header</li>
    </ul>
  </li>
</ul>

<h4 id="예시-2">예시</h4>

<p>IP, ARP, ICMP, RARP, OSPF</p>

<h2 id="l1-네트워크-연결-계층network-access-layernetwork-interface-layer">L1 네트워크 연결 계층(Network Access Layer/Network Interface Layer)</h2>

<p><strong>데이타 단위</strong>: 프레임
<strong>전송 주소</strong>: MAC</p>

<ul>
  <li>물리적으로 데이타가 네트워크를 통해 어떻게 전송되는지를 정의
    <ul>
      <li>논리주소(IP주소 등)이 아닌 물리주소(예. MAC주소(Media Access Control Address))을 참조해 장비간 전송</li>
      <li>MAC주소란 컴퓨터의 하드웨워 주소</li>
    </ul>
  </li>
  <li>기본적으로 에러검출/패킷의 프레임화 담당</li>
  <li>프레임(Frame)단위의 데이타 구성
    <ul>
      <li>최종적으로 데이타 전송을 하기 전 패킷헤더에 MAC주소와 오류 검출을 위한 부분을 첨부</li>
    </ul>
  </li>
</ul>

<h4 id="예시-3">예시</h4>

<p>MAC, LAN, 패킷망 등에 사용되는 것
예) Ethernet, PPP, Token Ring 등</p>

<p><br /></p>

<p>출처: <a href="https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층">https://velog.io/@jehjong/개발자-인터뷰-TCPIP-4계층</a></p>

	</div>
</article>
		</div>
	</div>
  </body>
</html>